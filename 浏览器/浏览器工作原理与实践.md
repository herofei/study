# 浏览器工作原理与实践

## 宏观视角上的浏览器

### 1. 最新的chrome浏览器架构

最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。

- <b>浏览器进程。</b>主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。

- <b>渲染进程。</b>核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。

- <b>GPU 进程。</b>其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。

- <b>网络进程。</b>主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。

- <b>插件进程。</b>主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：

- <b>更高的资源占用。</b>因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。

- <b>更复杂的体系架构。</b>浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。

### 2. 从输入URL到页面展示，这中间发生了什么？
1. 用户输入URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL
2. 用户输入完内容，按下回车键，浏览器导航栏显示loading状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得
3. 浏览器进程浏览器构建请求行信息，会通过进程间通信（IPC）将URL请求发送给网络进程
GET /index.html HTTP1.1
4. 网络进程获取到URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接200返回；否则，进入网络请求过程
5. 网络进程请求DNS返回域名对应的IP和端口号，如果之前DNS数据缓存服务缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的IP和端口号，如果没有端口号，http默认80，https默认443。如果是https请求，还需要建立TLS连接。
6. Chrome 有个机制，同一个域名同时最多只能建立 6 个TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个，会直接建立TCP连接。
7. TCP三次握手建立连接，http请求加上TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输
8. 网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层
9. 底层通过物理网络传输给目的服务器主机
10. 目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层
11. 目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层
12. 应用层HTTP解析请求头和请求体，如果需要重定向，HTTP直接返回HTTP响应数据的状态code301或者302，同时在请求头的Location字段中附上重定向地址，浏览器会根据code和Location进行重定向操作；如果不是重定向，首先服务器会根据 请求头中的If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回304状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；否则，返回新数据，200的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段：
Cache-Control:Max-age=2000
响应数据又顺着应用层——传输层——网络层——网络层——传输层——应用层的顺序返回到网络进程
13. 数据传输完成，TCP四次挥手断开连接。如果，浏览器或者服务器在HTTP头部加上如下信息，TCP就一直保持连接。保持TCP连接可以省下下次需要建立连接的时间，提示资源加载速度
Connection:Keep-Alive
14. 网络进程将获取到的数据包进行解析，根据响应头中的Content-type来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是text/html类型，就通知浏览器进程获取到文档准备渲染
15. 浏览器进程获取到通知，根据当前页面B是否是从页面A打开的并且和页面A是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程
16. 浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程
17. 浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页
18. 渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来


### 3. 浏览器渲染的过程

1. 渲染进程将 HTML 内容转换为能够读懂的DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成线程发送绘制图块命令DrawQuad给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

## JavaScript执行机制

### 4. JavaScript执行过程中的变量提升

1. JavaScript 代码执行过程中，需要先做变量提升，而之所以需要实现变量提升，是因为 JavaScript 代码在执行之前需要先编译。
2. 在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为 undefined；在代码执行阶段，JavaScript 引擎会从变量环境中去查找自定义的变量和函数
3. 如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定义的会覆盖掉之前定义的。
4. 如果变量和函数同名，那么在编译阶段，变量的声明会被忽略。

如果存在同名的变量和函数, 无论以下代码前后顺序如何，console.log出来的永远是function，因为JavaScript 引擎会先将在环境对象中创建一个名为 test 的属性，并使用 undefined 对其初始化,JavaScript 引擎发现了一个通过 function 定义的函数(function test)，所以它将函数定义存储到堆 (HEAP）中，并在环境对象中创建一个 test 的属性，然后将该属性值指向堆中函数的位置, 后者覆盖了前者

```JavaScript
console.log(test)
var test = 'aaa'
function test() {
    console.log('bbb')
}
// var test = 'aaa'
```

> [变量提升：JavaScript代码是按顺序执行的吗？](https://time.geekbang.org/column/article/119046)

### 5. JavaScript调用栈

1. 每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。
2. 如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。
3. 当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。
4. 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。


### 6.块级作用域

```javascript
let myname= '极客时间'
{ 
    console.log(myname)
    let myname= '极客邦'
}
```

> 【最终打印结果】：VM6277:3 Uncaught ReferenceError: Cannot access 'myname' before initialization
> 
> 【分析原因】：在块作用域内，let声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。
> 
> 【拓展】
> 
> var的创建和初始化被提升，赋值不会被提升。
> 
> let的创建被提升，初始化和赋值不会被提升。
> 
> function的创建、初始化和赋值均会被提升。


### 7.作用域链和闭包

- 我们把通过作用域查找变量的链条称为作用域链；作用域链是通过词法作用域来确定的，而词法作用域反映了代码的结构。
- 在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。

闭包的核心有两步：
- 第一步是需要预扫描内部函数
- 第二步是把内部函数引用的外部变量保存到堆中。

### 8.从JavaScript执行上下文的视角讲清楚this
- 当函数作为对象的方法调用时，函数中的 this 就是该对象；
- 当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；
- 嵌套函数中的 this 不会继承外层函数的 this 值
- 箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this

## V8工作原理


### 9.V8工作原理 - 栈空间和堆空间：数据是如何存储的

- 在使用之前就需要确认其变量数据类型的称为静态语言
- 支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言
- 原始类型的数据是存放在栈中，引用类型的数据是存放在堆中的。堆中的数据是通过引用和变量关联起来的。也就是说，JavaScript 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据。

### 10.V8工作原理 - 垃圾回收机制

详见[垃圾回收：垃圾数据是如何自动回收的？](https://time.geekbang.org/column/article/131233)

### 11.V8工作原理 - 编译器和解释器：V8是如何执行一段JavaScript代码的？

详见[编译器和解释器：V8是如何执行一段JavaScript代码的？](https://time.geekbang.org/column/article/131887)

## 浏览器页面循环系统

### 12.消息队列和事件循环

- 如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。
- 要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。
- 如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。
- 如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。
- 消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务。


### 13.WebAPI：setTimeout是如何实现的？

浏览器的页面是通过消息队列和事件循环系统来驱动的。settimeout的函数会被加入到延迟消息队列中，等到执行完Task任务之后就会执行延迟队列中的任务。然后分析几种场景下面的setimeout的执行方式。

1. 如果执行一个很耗时的任务，会影响延迟消息队列中任务的执行
2. 存在嵌套带调用时候，系统会设置最短时间间隔为4s（超过5层）
3. 未激活的页面，setTimeout最小时间间隔为1000ms
4. 延时执行时间的最大值2147483647，溢出会导致定时器立即执行
5. setTimeout设置回调函数this会是回调时候对应的this对象，可以使用箭头函数解决

### 14.宏任务和微任务：不是所有任务都是一个待遇

- 微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。
- 微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。
- 在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。
- MutationObserver 采用了“异步 + 微任务”的策略：1. 通过异步操作解决了同步操作的性能问题; 2.通过微任务解决了实时性的问题。


### 15.Promise：使用Promise，告别回调函数

* 详见<b>[Promise：使用Promise，告别回调函数](https://time.geekbang.org/column/article/136895)</b>

### 16.async/await：使用同步的方式去写异步代码

* 详见<b>[async/await：使用同步的方式去写异步代码](https://time.geekbang.org/column/article/137827)</b>


## 浏览器页面

### 17.Chrome开发者工具：利用网络面板做性能分析

* 详见[Chrome开发者工具：利用网络面板做性能分析](https://time.geekbang.org/column/article/138844)

### 18.DOM树：JavaScript是如何影响DOM树构建的？

* 详见[DOM树：JavaScript是如何影响DOM树构建的？](https://time.geekbang.org/column/article/140140)

### 19.渲染流水线：CSS如何影响首次加载时的白屏时间？

### 浏览器的渲染流程为(无js的情况下)：
1. 通过网络进程通过管道向渲染进程输入的字节流(Bytes)构建DOM(这期chrome会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据)。
2. 等待CSS文件加载完成后，构建CSSOM。
3. CSSOM和DOM一起构建布局树。
4. 渲染。

#### 浏览器的渲染流程为(有js的情况下)：
1. 通过网络进程通过管道向渲染进程输入的字节流(Bytes)构建DOM(这期chrome会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据)。
2. 在构建DOM过程中遇到JavaScript 脚本（内联或者外联同步脚本），浏览器会先暂停 DOM 解析去执行 JavaScript，因为 JavaScript 有可能会修改当前状态下的 DOM。
3. 不过在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。
4. 等待CSS文件加载完成后，构建CSSOM。
5. 执行JavaScript脚本。
6. 继续构建DOM。
7. CSSOM和DOM一起构建布局树。
8. 渲染。


#### 首屏优化策略

- 首屏渲染通常情况下的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。
- 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。
- 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。
- 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer。
- 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。


### 20.分层和合成机制：为什么CSS动画比JavaScript高效？
- 通常渲染引擎生成一帧图像有三种方式：重排、重绘和合成。其中重排和重绘操作都是在渲染进程的主线程上执行的，比较耗时；而合成操作是在渲染进程的合成线程上执行的，执行速度快，且不占用主线程。
- 合成的技术细节主要可以使用三个词来概括：分层、分块和合成。
- 如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层。但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以你需要恰当地使用 will-change。

### 21.页面性能：如何系统地优化页面？

- 加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。
- 交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。
- 关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。

#### 页面加载阶段优化

1. 减少关键资源个数。一种方式是可以将 JavaScript 和 CSS 改成内联的形式，比如上图的 JavaScript 和 CSS，若都改成内联模式，那么关键资源的个数就由 3 个减少到了 1 个。另一种方式，如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 async 或者 defer 属性；同样对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志。当 JavaScript 标签加上了 async 或者 defer、CSSlink 属性之前加上了取消阻止显现的标志后，它们就变成了非关键资源了。

2. 减少关键资源大小。可以压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中一些注释内容，也可以通过前面讲的取消 CSS 或者 JavaScript 中关键资源的方式。

3. 减少请求关键资源需要多少个 RTT（Round Trip Time）。RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。可以通过减少关键资源的个数和减少关键资源的大小搭配来实现。除此之外，还可以使用 CDN 来减少每次 RTT 时长。

### 页面交互阶段优化

1. 减少 JavaScript 脚本执行时间

2. 避免强制同步布局

3. 避免布局抖动

4. 合理利用 CSS 合成动画

5. 避免频繁的垃圾回收

### 22.渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？

* 详见[渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？](https://time.geekbang.org/column/article/144983)


### 23.WebComponent：像搭积木一样构建Web应用

#### webcomponent的几个关键技术点：
- Custom elements（自定义元素）
- Shadow DOM（影子 DOM）
- HTML templates（HTML 模板）

#### Shadow DOM（影子 DOM）的关键作用：
1. 影子 DOM 中的元素对于整个网页是不可见的
2. 影子 DOM 的 CSS 不会影响到整个网页的 CSSOM，影子 DOM 内部的 CSS 只对内部的元素起作用

浏览器为了实现影子 DOM 的特性，在代码内部做了大量的条件判断，比如当通过 DOM 接口去查找元素时，渲染引擎会去判断 geek-bang 属性下面的 shadow-root 元素是否是影子 DOM，如果是影子 DOM，那么就直接跳过 shadow-root 元素的查询操作。所以这样通过 DOM API 就无法直接查询到影子 DOM 的内部元素了。

另外，当生成布局树的时候，渲染引擎也会判断 geek-bang 属性下面的 shadow-root 元素是否是影子 DOM，如果是，那么在影子 DOM 内部元素的节点选择 CSS 样式的时候，会直接使用影子 DOM 内部的 CSS 属性。所以这样最终渲染出来的效果就是影子 DOM 内部定义的样式。

## 浏览器网络

### 24.HTTP/1：HTTP性能优化

#### http1.0 相较http0.9的改进：
1. 引入了请求头和响应头
2. 支持多种类型文件下载
3. 引入状态码
4. 提供了 Cache 机制
5. 为了统计客户端的基础信息，增加了用户代理的字段

#### http1.1 相较http1.0的改进：
1. 改进持久连接(keep-alive
2. 为了解决持久化连接的队头阻塞的问题，引入了HTTP 管线化技术(并不成功，已被多个浏览器厂商放弃)
3. 提供虚拟主机的支持。随着虚拟主机技术的发展，一台物理主机上可以绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址，HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址
4. 对动态生成的内容提供了完美支持。在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。HTTP/1.1 通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。


### 25.HTTP/2：如何提升网络速度？

#### 影响 HTTP/1.1 效率的三个主要因素：
1. tcp固有的慢启
2. TCP 连接之间相互竞争带宽问题
3. 由于长连接机制，就存在队头阻塞的问题

HTTP/2 的解决方案可以总结为：<b>一个域名只使用一个 TCP 长连接和消除队头阻塞问题。</b>

#### http2.0 相较http1.1的改进：

1. HTTP/2 最核心、最重要且最具颠覆性的<b>多路复用机制</b>。浏览器通过引入二进制分帧层，就实现了 HTTP 的多路复用技术。
2. 可以设置请求的优先级
3. 服务器推送
4. 头部压缩


### 26.HTTP/3：甩掉TCP、TLS 的包袱，构建高效网络

为了彻底解决TCP协议本身若干特性导致的网络延迟问题，HTTP3底层放弃TCP而选用UDP

HTTP/3 中的 QUIC 协议集合了以下几点功能：

1. 实现了类似 TCP 的流量控制、传输可靠性的功能。
2. 集成了 TLS 加密功能。
3. 实现了 HTTP/2 中的多路复用功能。

## 浏览器安全

### 同源策略：为什么XMLHttpRequest不能跨域请求资源？

浏览器安全可以分为三大块——Web 页面安全、浏览器网络安全和浏览器系统安全

#### 同源策略

如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。

同源策略主要表现在 DOM、Web 数据和网络这三个层面

1. DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。
2. 数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。
3. 网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。

解决http劫持篡改html文件嵌入恶意脚本，除了使用https的手段外，还可以使用CSP(内容安全策略)CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。

要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：：

1. 页面中可以引用第三方资源，不过这也暴露了很多诸如 XSS 的安全问题，因此又在这种开放的基础之上引入了 CSP 来限制其自由程度。
2. 使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的，因此浏览器又在这种严格策略的基础之上引入了跨域资源共享策略，让其可以安全地进行跨域操作。
3. 两个不同源的 DOM 是不能相互操纵的，因此，浏览器中又实现了跨文档消息机制，让其可以比较安全地通信。

详见如下资料：

* [内容安全策略( CSP )](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP)
* [浏览器安全策略 CSP 部署：Teambition 实战](https://www.teambition.com/developer/blog/article?_id=5438e83ee903ca681810f174)

### 27.跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？

恶意脚本的注入方式：

#### 1.存储型 XSS 攻击

* 首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；
* 然后用户向网站请求包含了恶意 JavaScript 脚本的页面；
* 当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。

#### 2.反射型 XSS 攻击

在一个反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。

#### 3.基于 DOM 的 XSS 攻击

基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。

#### 如何防止XSS 攻击
1. 服务器对输入脚本进行过滤或转码
2. 充分利用 CSP(内容安全策略)
3. 使用 HttpOnly 属性


### 28.CSRF攻击：陌生链接不要随便点

CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。

#### CSRF的三种攻击方式

1. 自动发起 Get 请求
2. 自动发起 POST 请求
3. 引诱用户点击链接

#### 如何防止CSRF

1. 充分利用好 Cookie 的 SameSite 属性

> <b>SameSite 选项通常有 Strict、Lax 和 None 三个值。</b>
> * Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 InfoQ 的服务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。
> * Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。
> * 而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。

2. 验证请求的来源站点。主要通过验证HTTP 请求头中的 Referer 和 Origin 属性。

3. CSRF Token。在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。

### 29.安全沙箱：页面和系统之间的隔离墙

* 详见[安全沙箱：页面和系统之间的隔离墙](https://time.geekbang.org/column/article/155183)

### 30.HTTPS：让数据传输更安全

#### HTTPS 的握手过程:

1. 首先是tcp的三次握手建立连接
2. client发送random1+支持的加密算法集合（clientHello）
3. server收到信息，返回选择一个加密算法+random2（serverHello）+ 证书+ 确认
4. clent验证证书有效性，并用random1+random2生成pre-master通过服务器公钥加密 发送给server
5. server收到premaster，根据约定的加密算法对random1+random2+premaster（解密）生成master-secret，然后发送预定成功
6. client收到生成同样的master-secert，对称加密秘钥传输完毕

#### 浏览器安全主要包括页面安全、系统安全、传输安全三个部分。https主要保证传输过程的安全，从防止中间人窃取修改伪造的角度循序渐进的介绍了https的实现过程。

1. 对称加密传输（协商秘钥的过程容易被窃取）
2. 非对称加密传输（服务端用私钥加密的内容，可以通过它的公钥进行解密）
3. 非对称加密交换秘钥、对称加密传输内容（DNS劫持 如何保证服务器是可信的）
4. 引入CA权威机构保证服务器可信性。

#### 数字证书的申请过程：
* 服务器生成一对公钥和私钥，私钥自己保存，通过公钥+企业+网站信息去CA机构申请证书。
* CA机构通过全方位的验证给这个网站颁发证书，证书内容包括企业信息、证书有效期、证书编号，以及自己私钥加密上述信息的摘要、网站的公钥。
* 服务器就获得了CA的认证。

#### 浏览器认证证书过程:
* 浏览器从服务器拿到网站的证书，通过CA的公钥解密证书信息的摘要跟使用摘要算法计算企业信息等的摘要对比，如果一致则证明证书有效。
* 如果证书CA是可靠的呢，通过给CA颁发证书的根CA验证，通常操作系统中包括顶级CA证书（它们自己给自己签名称为自签名证书，我们自己生成证书也是自签名证书 只是它不是操作系统内置的）

* 详见[HTTPS：让数据传输更安全](https://time.geekbang.org/column/article/156181)