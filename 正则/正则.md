# 正则总结

## 1. 正则规则小抄

### 字符匹配
字符|说明
:---|:--
\ | 转义符
\d | [0-9]。表示是一位数字。记忆方式：其英文是digit（数字）。
\D | [\^0-9]。表示除数字外的任意字符。
\w | [0-9a-zA-Z_]。表示数字、大小写字母和下划线。记忆方式：w是word的简写，也称单词字符。
\W | [\^0-9a-zA-Z_]。非单词字符。
\s | [\t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母。
\S | [\^\t\v\n\r\f]。 非空白符。
.  | [\^\n\r\u2028\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。
\uxxxx | 查找以十六进制数 xxxx 规定的 Unicode 字符。
[abc] | any of a, b, or c
[\^abc] | not a, b, or c
[a-g] | character between a & g

### 位置匹配
字符|说明
:---|:--
\b | 是单词边界，具体就是\w和\W之间的位置，也包括\w和 ^ 之间的位置，也包括\w和 $ 之间的位置。具体说来就是\w与\w、\W与\W、 ^ 与\W，\W与 $ 之间的位置。
\B | 是\b的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉\b，剩下的都是\B的。
\^abc$ | start / end of the string

### 组
字符|说明
:---|:--
(abc) | capture group，捕获组
\1 | backreference to group #1，分组引用，引用第一个捕获组匹配的内容
(?:abc) | non-capturing group，非捕获组

### 先行断言
字符|说明
:---|:--
a(?=b) | positive lookahead，先行断言，a只有在b前面才匹配
a(?!b) | negative lookahead，先行否定断言，a只有不在b前面才匹配

### 后行断言
字符|说明
:---|:--
(?<=b)a | positive lookbehind，后行断言，a只有在b后面才匹配
(?<!b)a | negative lookbehind，后行否定断言，a只有不在b后面才匹配

### 量词和分支
字符|说明
:---|:--
a* | 0 or more
a+ | 1 or more
a? | 0 or 1
a{5} | exactly five
a{2,} | two or more
a{1,3} | between one & three
a+?a{2,}? | match as few as possible，惰性匹配，就是尽可能少的匹配

以下都是惰性匹配<br>
{m,n}? <br>
{m,}?<br>
??<br>
+?<br>
*?

### 分支
<table>
    <thead>
        <tr>
            <th>字符</th>
            <th>说明</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>ab<span>|</span>cd</td>
            <td>match ab or cd，匹配'ab'或者'cd'字符子串</td>
        </tr>
    </tbody>
</table>

### 修饰符
字符|说明
:---|:--
i | 执行对大小写不敏感的匹配。
g | 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。
m | 执行多行匹配。
u | 开启"Unicode 模式"，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。
y | y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是"粘连"的涵义

## 2. 运算符优先级

见  http://www.runoob.com/regexp/regexp-operator.html

<table>
    <thead>
        <tr>
            <th>运算符</th>
            <th>描述</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>\</td>
            <td>转义符</td>
        </tr>
        <tr>
            <td>(), (?:), (?=), []</td>
            <td>圆括号和方括号</td>
        </tr>
        <tr>
            <td>*, +, ?, {n}, {n,}, {n,m}</td>
            <td>限定符</td>
        </tr>
        <tr>
            <td>^, $, \任何元字符、任何字符</td>
            <td>定位点和序列（即：位置和顺序）</td>
        </tr>
        <tr>
            <td>|</td>
            <td>替换，"或"操作<br>
字符具有高于替换运算符的优先级，使得"m|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m|f)ood"。</td>
        </tr>
    </tbody>
</table>

## 3. 正则相关API

### Regex实例methods

* test

检索字符串中的指定子串，返回布尔值
```
/^\d[a-zA-Z]{3}$/.test('1aac') // true
```

* exec

返回一个数组，数组中的第一个条目是第一个匹配
```
/^\d[a-zA-Z]{3}$/.exec('1aac') // ["1aac"]
```

### String实例正则相关methods

* search

返回子串的开始位置
```
'a12b2334c34'.search(/\d{4}/) // 4
```

* match

返回匹配到的子串
```
'a12b2334c34'.match(/\d{4}/) // ["2334"]
```

* matchAll (ES6+)

可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组
```
const string = 'test1test2test3';

// g 修饰符加不加都可以
const regex = /t(e)(st(\d?))/g;

for (const match of string.matchAll(regex)) {
  console.log(match);
}
// ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]
// ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]
// ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]
```

* replace

替换匹配到的子串
```
'a12b2334c34'.replace(/\d{4}/, 'cccc') // "a12bccccc34"
```

* split

将字符串分割成数组
```
'a12b2334c34'.split(/\d{4}/) // ["a12b", "c34"]
```

## 4. 常用正则

### 日常应用

* 校验密码强度

密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。
```
^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$
```

* 校验中文

字符串仅能是中文。
```
^[\u4e00-\u9fa5]{0,}$
```

* 邮编验证
```
[1-9]d{5}(?!d)
```

* 校验身份证号码

下面是身份证号码的正则校验。15 或 18位。

15位：
```
^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$
```
18位：
```
^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}([0-9]|X)$
```

* 校验日期

“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。
```
^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$
```

* 校验金额

金额校验，精确到2位小数。
```
^[0-9]+(.[0-9]{2})?$
```

* 校验手机号

下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）
```
^1\d{10}$
```

* 提取Color Hex Codes

有时需要抽取网页中的颜色代码，可以使用下面的表达式。
```
^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$
```

* 抽取注释

如果你需要移除HMTL中的注释，可以使用如下的表达式。
```
<!--(.*?)-->
```

* 去掉字符串左右两边的空格

" work " --> "work"
```
function trim(str) {
    return str.replace(/(^\s*)|(\s*$)/g, "")
}

let str = "  work "
console.log(trim(str)) // "work"
```

### 网络相关
* 校验E-Mail 地址

同密码一样，下面是E-mail地址合规性的正则检查语句。
```
/^(\w+)([\-+.][\w]+)*@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/
```

* 检查URL的前缀

应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。
```
if (!s.match(/^[a-zA-Z]+:\/\//))
{
    s = 'http://' + s;
}
```

* 提取URL链接

下面的这个表达式可以筛选出一段文本中的URL。
```
/^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/
```

* 校验IP-v4地址

IPV4 正则语句。
```
/\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/

or

String.format('^({0}\\.{0}\\.{0}\\.{0})$','(?:\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])'))
```

* 校验IP-v6地址

IPV6 正则语句。
```
/^([\da-fA-F]{1,4}:){6}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])(\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])){3}$|^([\da-fA-F]{1,4}:){1,5}:(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])(\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])){3}$|^::(([\da-fA-F]{1,4}:){0,5})(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])(\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])){3}$|^([\da-fA-F]{1,4}::([\da-fA-F]{1,4}:){0,4})(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])(\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])){3}$|^(([\da-fA-F]{1,4}:){2}:([\da-fA-F]{1,4}:){0,3})(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])(\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])){3}$|^(([\da-fA-F]{1,4}:){3}:([\da-fA-F]{1,4}:){0,2})(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])(\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])){3}$|^(([\da-fA-F]{1,4}:){4}:([\da-fA-F]{1,4}:){0,1})(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])(\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])){3}$|^:((:[\da-fA-F]{1,4}){1,7}|:)$|^([\da-fA-F]{1,4}:){1}((:[\da-fA-F]{1,4}){1,6}|:)$|^([\da-fA-F]{1,4}:){2}((:[\da-fA-F]{1,4}){1,5}|:)$|^([\da-fA-F]{1,4}:){3}((:[\da-fA-F]{1,4}){1,4}|:)$|^([\da-fA-F]{1,4}:){4}((:[\da-fA-F]{1,4}){1,3}|:)$|^([\da-fA-F]{1,4}:){5}((:[\da-fA-F]{1,4}){1,2}|:)$|^([\da-fA-F]{1,4}:){6}((:[\da-fA-F]{1,4})|:)$|^([\da-fA-F]{1,4}:){7}(([\da-fA-F]{1,4})|:)$/
```

* MAC 地址

请输入一个有效的MAC地址，如：00:E0:4C:0E:9A:2F或00-E0-4C-0E-9A-2F

```
/^((\d|([a-f]|[A-F])){2}:){5}(\d|([a-f]|[A-F])){2}$/.test(v)
|| /^((\d|([a-f]|[A-F])){2}-){5}(\d|([a-f]|[A-F])){2}$/.test(v)
```

* 匹配IP/子网掩码

ip/mask型

```
/^(((\\d{1,2}|0\\d{2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d{1,2}|0\\d{2}|1\\d\\d|2[0-4]\\d|25[0-5]))\\/(((\\d{1,2}|0\\d{2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d{1,2}|0\\d{2}|1\\d\\d|2[0-4]\\d|25[0-5]))$/
```

ip/number型

```
/^(((\\d{1,2}|0\\d{2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d{1,2}|0\\d{2}|1\\d\\d|2[0-4]\\d|25[0-5]))\\/(\\d|[12]\\d|3[012])$/
```

* 匹配域名
```
/^([\da-zA-Z\.-]+)\.([a-zA-Z]{2,6})$/
```

* 验证端口号
```
/^\d{1,5}$/.test(v) && parseInt(v, 10) < 65536
```


### 数字相关
* 匹配正整数
```
/^[1-9]\d*$/;
```

* 匹配负整数
```
/^-[1-9]\d*$/;
```

* 匹配整数
```
/^-?[1-9]\d*$/;
```

* 匹配非负整数（正整数 + 0）
```
/^[1-9]\d*|0$/;
```

* 匹配非正整数（负整数 + 0）
```
/^-[1-9]\d*|0$/;
```

* 匹配正浮点数
```
/^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$/;
```

* 匹配负浮点数
```
/^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$/;
```

* 匹配浮点数
```
/^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$/;
```

* 匹配非负浮点数（正浮点数 + 0）
```
/^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$/;
```

* 匹配非正浮点数（负浮点数 + 0）
```
/^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$/;
```

* 格式化数字

1234567890 --> 1,234,567,890

```
let test1 = '1234567890'
let format = test1.replace(/\B(?=(\d{3})+(?!\d))/g, ',')

console.log(format) // 1,234,567,890
```

* 判断一个数是否为质数

11 --> true
```
function isPrime(num) {
    return !/^1?$|^(11+?)\1+$/.test(Array(num+1).join('1'));
}

console.log(isPrime(19)) // true
```


## 5. 正则回溯

[查看这篇文章](https://zhuanlan.zhihu.com/p/27653434)

## 6. 正则引擎

本章节引用以下博文片段

[正则表达式前端使用手册](https://juejin.im/entry/58c78c082f301e006bcfa8f2)

目前正则引擎有两种, DFA 和 NFA, NFA又可以分为传统型NFA和POSIX NFA.

* DFA Deterministic finite automaton 确定型有穷自动机
* NFA Non-deterministic finite automaton　非确定型有穷自动机
* Traditional NFA
* POSIX NFA

DFA引擎不支持回溯, 匹配快速, 并且不支持捕获组, 因此也就不支持反向引用. 上述awk, egrep命令均支持 DFA引擎.

POSIX NFA主要指符合POSIX标准的NFA引擎, 像 javaScript, java, php, python, c#等语言均实现了NFA引擎.

有关正则表达式详细的匹配原理, 建议选读 Jeffrey Friedl 的 <精通正则表达式>[第三版] 中第4章-表达式的匹配原理(p143-p183), Jeffrey Friedl 对正则表达式有着深刻的理解.

有关NFA引擎的简单实现, 可以参考文章 [基于ε-NFA的正则表达式引擎 - twoon](http://www.cnblogs.com/catch/p/3722082.html)

## 7. 相关链接

[正则30分钟入门](http://deerchao.net/tutorials/regex/regex.htm)

[hackerrank, 正则学习闯关](https://www.hackerrank.com/domains/regex)

[正则学习及练习](https://regexr.com/)

[正则可视化](https://regexper.com/#)

[正则可视化2](https://jex.im/regulex/#!flags=i&re=)

[不错的正则教程](https://zhuanlan.zhihu.com/p/27653434)

[stackoverflow中关于正则的一些经典问题](https://stackoverflow.com/tags/regex/info)

[Regex Cross­word, 正则闯关](https://regexcrossword.com/)

[正则练习](https://alf.nu/RegexGolf)

[regexone, 正则闯关练习](https://regexone.com/)

[正则匹配原理解析](https://swtch.com/~rsc/regexp/regexp1.html)

[learncodethehardway](https://learncodethehardway.org/regex/)

[正则匹配原理解析](https://swtch.com/~rsc/regexp/)

