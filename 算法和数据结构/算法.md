## 0. 大O表示法

大O表示法指出了算法的运行速度，大O表示法表示了算法在最糟的情况下的运行时间，大O表示法会省略操作时间前面的常数，所以例如运行时间长度为1/2 * n^2也会表示为O(n^2).
比较两个算法复杂度不一样的算法，在数据量足够大的时候，大O表示法前面的运行常量是无关紧要，足以忽略的。但是如果两个算法复杂度一样的算法比较的时候，这个常量则是事关重要的.

常见的大O表示法的运行时间
* O(1),常量时间，就是不管数据量多少，算法操作的时间都一样，如用散列表查找
* O(log n)，也叫对数时间，这样的算法包括二分查找
* O(n)，也叫线性时间，这样的算法包括简单查找
* O(n * log n)，这样的算法包括快速排序
* O(n^2)，这样的算法包括选择排序
* O(n!)，极其慢的算法，这样的算法包括商旅问题算法

## 1.查找算法

### 1.1 简单查找

就是简单的一个一个查找.
最简单的查找方法，也是运行速度最慢的查找方法，所有数据都查找一遍，算法复杂度:O(n).

### 1.2 二分法查找

每次都从中间开始差.以此不断缩小查找范围.
运行速度较快的查找方法，算法复杂度:O(log n)

## 2. 排序算法

排序名称 | 时间复杂度(最佳情况) | 时间复杂度(平均情况) | 时间复杂度(最坏情况) | 占用内存 | 稳定性
:--- | :-- | :--- |:-- | :--- | :--
选择排序 | n^2 | n^2 | n^2 | 1 | No
冒泡排序 | n | n^2 | n^2 | 1 | Yes
插入排序 | n | n^2 | n^2 | 1 | Yes
希尔排序 | nlog(n) | 与步长序列有关 | n(log(n))^2 | 1 | No
快速排序 | nlog(n) | nlog(n) | n^2 | log(n) | 1 | No
归并排序 | nlog(n) | nlog(n) | nlog(n) | n | 1 | Yes

### 2.1 选择排序

先从无序列表中找出最小值，再从剩余的无序列表中找出最小值，不断以此循环排序.

最简单的排序算法，也是最慢的排序算法之一，算法复杂度为：O(n^2).

[选择排序的js代码实现](https://github.com/herofei/Data-structure-ALgorithims-with-Js/blob/master/Algorithms/sort/selectionSort.js)

### 2.2 冒泡排序

冒泡排序算法的运作如下：

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

```
\\  伪代码如下

函数 冒泡排序 输入 一个数组名称为array 其长度为length 
    i 从 0 到 (length - 1) 
        j 从 0 到 (length - 1 - i) 
            如果 array[j] > array[j + 1] 
                交换 array[j] 和 array[j + 1] 的值 
            如果结束 
        j循环结束 
    i循环结束 
函数结束
```

[冒泡排序的js代码实现](https://github.com/herofei/Data-structure-ALgorithims-with-Js/blob/master/Algorithms/sort/bubbleSort.js)

### 2.3 插入排序

一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5

如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找插入排序。

[插入排序的js代码实现](https://github.com/herofei/Data-structure-ALgorithims-with-Js/blob/master/Algorithms/sort/insertionSort.js)

### 2.4 希尔排序

例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：
```
13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10

```

然后我们对每列进行排序：
```
10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45
```

将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：
```
10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
```

排序之后变为：
```
10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
```

最后以1步长进行排序（此时就是简单的插入排序了）。

```
// 伪代码

输入：1个阵列名称为a，1个长度名称为n，阵列的编號从0到n - 1
整数inc从n / 2到1每次迴圈inc变为inc / 2
	i从inc到n - 1每次迴圈i变为i + 1
		將a[i]的值丟到temp
		j从i - inc到0每次迴圈j变为j - inc
			如果a[j]大於temp则將a[j + inc]的值丟到a[j]
			否则跳出j迴圈
		j迴圈结束
		將temp的值丟到a[j + inc]
	i迴圈结束
inc迴圈结束
```

[希尔排序的js代码实现](https://github.com/herofei/Data-structure-ALgorithims-with-Js/blob/master/Algorithms/sort/shellSort.js)

### 2.5 快速排序

1. 选择一个基准值(一般默认取数组的第一个元素)，并将列表分隔成两个子序列
2. 对列表重新排序，将所有小于基准值的元素放在基准值的前面，所有大于基准值的元素放在基准值的后面
3. 分别对较小元素的子序列和较大元素的子序列重复步骤1和2，直至最终排序完成

快速排序采用的是分治法思想

运行时间取决于选择的基准值，最差的情况下运行时间为：O(n^2)，平均（也是最佳）情况下算法运行时间为O(n * log n).

最糟情况：调用栈的高度运行时间为O(n) * 每层调用运行时间O(n).

最佳情况：调用栈的高度运行时间为O(log n) * 每层调用运行时间O(n).

[快速排序的js代码实现](https://github.com/herofei/Data-structure-ALgorithims-with-Js/blob/master/Algorithms/sort/quickSort.js)

### 2.6 合并排序(归并排序)

归并排序采用的也是分治法思想

实现归并排序有两种思路，一种是递归法，另一种是迭代法

#### 递归法（Top-down，自顶向下）

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针到达序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾


### 迭代法（Bottom-up，自底向上）

1. 将序列每相邻两个数字进行归并操作，形成 {\displaystyle ceil(n/2)} {\displaystyle ceil(n/2)}个序列，排序后每个序列包含两/一个元素
2. 若此时序列数不是1个则将上述序列再次归并，形成 {\displaystyle ceil(n/4)} {\displaystyle ceil(n/4)}个序列，每个序列包含四/三个元素
3. 重复步骤2，直到所有元素排序完毕，即序列数为1

运行时间总是等于O(n * log n),但同等算法复杂度（指快速排序的平均算法复杂度）的情况下，其运行单个运行时间常量比快速排序长，所以日常中使用快速排序较多.

[归并排序的js代码实现](https://github.com/herofei/Data-structure-ALgorithims-with-Js/blob/master/Algorithms/sort/mergeSort.js)

## 3. 图算法

### 3.1 广度优先搜索算法

算法复杂度:O(V+E),其中V为顶点数,E为边数.用于解决以下问题：

* 从节点A出发，有前往节点B的路径吗？
* 从节点A出发，前往节点B的哪条路径最短？
* 广义优先搜索用于在非加权图中查找最短路径.


### 3.2 狄克斯特拉算法 *(important)

* 狄克斯特拉算法用于在加权图中查找最短路径.
* 仅当图中权重均为正时狄克斯特拉算法才管用.
* 如果图中包含负权重边时，请使用贝尔曼-福德算法.


## 4. 其他

### 4.1 贪婪算法

* 贪婪算法是寻找局部最优解，企图以这种方式获得全局最优解
* 贪婪算法易于实现，运行速度快，是不错的近似解算法
* 对于NP完全问题，还没找到快速解决方案
* 面临NP完全问题，最佳做法是使用近似算法

### 4.2 动态规划

* 动态规划是通过解决简单的子问题，进而推导出解决大问题的方法
* 动态规划最多只会合并2个子问题的最优解，不会超过2个
* 在问题可分解为彼此独立且离散的子问题的时候，就可使用动态规划
* 每种动态规划解决方案都涉及网格
* 单元格中的值通常是你要优化的值
* 每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题

应用：

* 生物学家根据最长公共序列来确定DNA链的相似性，进而判断两种生物有多相似最长公共序列就是用动态规划实现的
* git diff,指出两个文件的差异，就是用动态规划实现的
* 编辑距离，指出两个字符串的相似程度，就是使用动态规划实现的

### 4.3 K最近邻(KNN)算法

* KNN 算法用与分类和回归,需要考虑最近邻居
* 分类就是编组
* 回归就是预测结果
* 特征抽取意味着将一系列目标特征转化成一系列可以比较的数字
* 能否挑选合适的特征转化成相关数值就是KNN算法成败的关键

### 4.4 SHA算法

* 一种散列算法

### 4.5 MD5算法

* 另一种广泛应用的散列算法
  
