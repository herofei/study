### 0. 大O表示法

大O表示法指出了算法的运行速度，大O表示法表示了算法在最糟的情况下的运行时间，大O表示法会省略操作时间前面的常数，所以例如运行时间长度为1/2 * n^2也会表示为O(n^2).
比较两个算法复杂度不一样的算法，在数据量足够大的时候，大O表示法前面的运行常量是无关紧要，足以忽略的。但是如果两个算法复杂度一样的算法比较的时候，这个常量则是事关重要的.

常见的大O表示法的运行时间
* O(1),常量时间，就是不管数据量多少，算法操作的时间都一样，如用散列表查找
* O(log n)，也叫对数时间，这样的算法包括二分查找
* O(n)，也叫线性时间，这样的算法包括简单查找
* O(n * log n)，这样的算法包括快速排序
* O(n^2)，这样的算法包括选择排序
* O(n!)，极其慢的算法，这样的算法包括商旅问题算法

### 1.简单查找

就是简单的一个一个查找.
最简单的查找方法，也是运行速度最慢的查找方法，所有数据都查找一遍，算法复杂度:O(n).

### 2.二分法查找

每次都从中间开始差.以此不断缩小查找范围.
运行速度较快的查找方法，算法复杂度:O(log n)

### 3.选择排序

先从无序列表中找出最小值，再从剩余的无序列表中找出最小值，不断以此循环排序.
最简单的排序算法，也是最慢的排序算法，算法复杂度为：O(n^2).

### 4.冒泡排序

### 5.插入排序

### 6.希尔排序

### 7.快速排序

随机挑取无序列表中的一个值作为基准值，然后分出小于该基准值和大于该基准值的两个无序列表.再分别在这两个无序列表中随机调出基准值，不断重复第一步的操作，直至排序结束.
运行时间取决于选择的基准值，最差的情况下运行时间为：O(n^2)，平均（也是最佳）情况下算法运行时间为O(n * log n).

最糟情况：调用栈的高度运行时间为O(n) * 每层调用运行时间O(n).

最佳情况：调用栈的高度运行时间为O(log n) * 每层调用运行时间O(n).

### 8.合并排序(归并排序)

运行时间总是等于O(n * log n),但同等算法复杂度（指快速排序的平均算法复杂度）的情况下，其运行单个运行时间常量比快速排序长，所以日常中使用快速排序较多.

### 9.广度优先搜索算法

算法复杂度:O(V+E),其中V为顶点数,E为边数.用于解决以下问题：

* 从节点A出发，有前往节点B的路径吗？
* 从节点A出发，前往节点B的哪条路径最短？
* 广义优先搜索用于在非加权图中查找最短路径.


### 10.狄克斯特拉算法 *(important)

* 狄克斯特拉算法用于在加权图中查找最短路径.
* 仅当图中权重均为正时狄克斯特拉算法才管用.
* 如果图中包含负权重边时，请使用贝尔曼-福德算法.

### 11.贪婪算法

* 贪婪算法是寻找局部最优解，企图以这种方式获得全局最优解
* 贪婪算法易于实现，运行速度快，是不错的近似解算法
* 对于NP完全问题，还没找到快速解决方案
* 面临NP完全问题，最佳做法是使用近似算法

### 动态规划

* 动态规划是通过解决简单的子问题，进而推导出解决大问题的方法
* 动态规划最多只会合并2个子问题的最优解，不会超过2个
* 在问题可分解为彼此独立且离散的子问题的时候，就可使用动态规划
* 每种动态规划解决方案都涉及网格
* 单元格中的值通常是你要优化的值
* 每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题

### 最近邻算法

### SHA算法

