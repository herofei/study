### 1. 数组 VS 2.链表

数组的优势在于读取，链表的优势在于插入和删除

以下为各个操作的算法复杂度：

操作|数组|链表
---|:--:|---:
读取|O(1)|O(n)
插入|O(n)|O(1)
删除|O(n)|O(1)

这是因为数组读取的时候只需要根据索引就能找到对应的值,而链表则需一个一个的根据指向找到相应索引的值

数组插入元素要使后面所有元素的索引都往后移（而且如果分配的内存空间不足，还得进行数据转移），而链表则只需要修改前面一个元素的指向地址

数组删除元素要使后面所有元素的索引都往前移，而链表也是只需要修改前面一个元素的指向地址即可

需要指出的是，仅当能够立即访问要插入前一位置的元素(删除操作则是删除的元素)的时候，链表的删除操作的运行时间才为O(1)。

### 3.栈

特点：后入先出(LIFO),函数调用过程中经常出现的数据结构，调用栈。

### 4.队列

特点：先入先出(FIFO)

### 5.散列表

散列表其实是由散列函数和数组创建的一种数据结构。输入通过散列函数返回的映射数字为索引，在数组中找到相应的输出。散列表一般用于模拟映射关系。

散列函数有以下特点：

* 它必须是一致的,对于每个相同的输入值必须返回相同的输出值。
* 它应将不同的输入值映射到不同的数字。如果一个散列函数不管输入什么都返回1，它就不是一个好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。


散列表由键值对组成，散列表将键映射到值。

散列表在python中的实现为字典，在JavaScript中的实现为对象。

散列表的日常应用举例：

* DNS解析用的数据结构也是散列表，通过域名去找相应的IP。
* 缓存处理
* 防止重复


散列表的碰撞处理(冲突处理)

* 散列表还是有可能冲突的，但不同的输入值通过映射函数映射到同一个数字的时候，就会发生冲突。
* 解决方法一，开链法。是在数组的该索引位置存储一个链表，链表存放冲突的输出值。
* 解决方法二，线性探测法。线性探测法检查散列表中下一个位置是否为空。如果是空就就将该数据存入该位置；如果不为空，则继续检查下一个位置，直到找到一个空的位置为止。
* 如果散列数组的大小是待存储数据个数的1.5倍左右时，建议使用开链法；如果数组的大小是待存储数据的2倍及以上时，则使用线性探测法。

操作|数组|链表|散列表（平均情况，也是最佳情况）|散列表（最糟情况）
---|:--:|:--:|:--:|---:
读取|O(1)|O(n)|O(1)|O(n)
插入|O(n)|O(1)|O(1)|O(n)
删除|O(n)|O(1)|O(1)|O(n)


要想提高散列表的性能，有两个关键要素：

* 较低的填装因子(填装因子为散列表包含的元素数/数组的位置总数(长度))。一旦填装因子大于0.7，就需要调整数组长度，这是个相当浪费时间的过程。
* 良好的散列函数(如SHA函数)。

### 6.集合(Set)

集合有以下特点：

* 集合的成员是无序的
* 集合中不允许相同成员存在

集合运算(以下为伪代码)：

* 交集，set(['a', 'b']) & set(['a', 'c']) 
* 并集，set(['a', 'b']) | set(['a', 'c']) 
* 差集，set(['a', 'b']) - set(['a', 'c']) ，属于前者但不属于后者

### 无向图


### 有向图


### 二叉树

* 二叉树(Binary Tree)是个特殊的树，它的子节点个数不超过两个。
* 从一个节点到另一个节点的这一组边称为路径。
* 以某种特定的顺序访问书中的所有节点称为树的遍历。
* 树可以分为几个层级，根节点为第0层，子节点是第一层，子节点的子节点为第2层，以此类推。

#### 二叉查找树

* 二叉查找树(Binary Search Tree)是一种特殊的二叉树，简称BST。
* 二叉查找树的相对较小的值会保存在左节点中，较大的值会保存在右节点中。
* 这一特性使得二叉查找树的查找效率非常高，对于数值型和非数值型的数据，比如单词和字符串，都是如此。

[二叉查找树的js代码实现](https://github.com/herofei/Data-structure-ALgorithims-with-Js/blob/master/Data-Structure/BST.js)

### 红黑树


### 堆