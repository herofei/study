### 1. 数组 VS 2.链表

数组的优势在于读取，链表的优势在于插入和删除

以下为各个操作的算法复杂度：

操作|数组|链表
---|:--:|---:
读取|O(1)|O(n)
插入|O(n)|O(1)
删除|O(n)|O(1)

这是因为数组读取的时候只需要根据索引就能找到对应的值,而链表则需一个一个的根据指向找到相应索引的值

数组插入元素要使后面所有元素的索引都往后移（而且如果分配的内存空间不足，还得进行数据转移），而链表则只需要修改前面一个元素的指向地址

数组删除元素要使后面所有元素的索引都往前移，而链表也是只需要修改前面一个元素的指向地址即可

需要指出的是，仅当能够立即访问要插入前一位置的元素(删除操作则是删除的元素)的时候，链表的删除操作的运行时间才为O(1)。

### 3.栈

特点：后入先出(LIFO),函数调用过程中经常出现的数据结构，调用栈。

### 4.队列

特点：先入先出(FIFO)

### 5.散列表

散列表其实是由散列函数和数组创建的一种数据结构。输入通过散列函数返回的映射数字为索引，在数组中找到相应的输出。散列表一般用于模拟映射关系。

散列函数有以下特点：

* 它必须是一致的,对于每个相同的输入值必须返回相同的输出值。
* 它应将不同的输入值映射到不同的数字。如果一个散列函数不管输入什么都返回1，它就不是一个好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。


散列表由键值对组成，散列表将键映射到值。

散列表在python中的实现为字典，在JavaScript中的实现为对象。

散列表的日常应用举例：

* DNS解析用的数据结构也是散列表，通过域名去找相应的IP。
* 缓存处理
* 防止重复

散列表还是有可能冲突的，但不同的输入值通过映射函数映射到同一个数字的时候，就会发生冲突。一般处理冲突的手段是在数组得该索引位置存储一个链表，链表存放冲突的输出值。

操作|数组|链表|散列表（平均情况，也是最佳情况）|散列表（最糟情况）
---|:--:|:--:|:--:|---:
读取|O(1)|O(n)|O(1)|O(n)
插入|O(n)|O(1)|O(1)|O(n)
删除|O(n)|O(1)|O(1)|O(n)

要想提高散列表的性能，有两个关键要素：
* 较低的填装因子(填装因子为散列表包含的元素数/数组的位置总数(长度))。一旦填装因子大于0.7，就需要调整数组长度，这是个相当浪费时间的过程
* 良好的散列函数(如SHA函数)

### 6.集合(Set)

集合有以下特点：

* 集合的成员是无序的
* 集合中不允许相同成员存在

集合运算(以下为伪代码)：

* 交集，set(['a', 'b']) & set(['a', 'c']) 
* 并集，set(['a', 'b']) | set(['a', 'c']) 
* 差集，set(['a', 'b']) - set(['a', 'c']) ，属于前者但不属于后者

### 无向图


### 有向图


### 二叉树


### 红黑树


### 堆