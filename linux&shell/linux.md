# Linux

## 1. 概要与杂项

### X Window与命令行模式的切换
  
X Window是窗口管理器环境, Linux最常用的是命令行界面(也叫终端界面、Terminal或者Console), Linux默认情况下会提供六个终端来让用户登录, 切换方式为使用: [Ctrl + Alt + F1~F6]的组合键, 系统会将[F1] ~ [F6] 命名为tty1 ~ tty6的操作接口环境。

### Linux在线求助

1. Linux所有命令都会有--help参数, 可以方便查看该命令的用法
2. 使用man命令, man是manual(操作说明)的简写, 使用man [command] 可以查看该command的说明.
3. 使用info命令, 使用info [command] 可以查看该command的说明, 但是与man一口气输出一堆信息不同的是, info page则是将文件数据拆成一个一个的段落, 每个段落用自己的页面来编写, 并且各个页面中还有类似网页的超链接来跳到各不同的页面中, 每个独立的页面也被称为一个节点. 所以, 你可以将info输出的info page想成是命令行模式的网页显示数据.

### 如何关机Linux

与关机有关的命令：

- sync: 将数据同步写入硬盘中
- shutdown: 关机
- halt: 系统停止, 屏幕可能会保留系统已经停止的信息
- poweroff: 系统关机, 所以没有提供额外的电力, 屏幕空白
- reboot: 重新启动
- suspend: 进入休眠模式

目前shutdown、reboot、halt等命令均会在关机前调用sync, 确保数据完整.

## 2. 权限与目录配置

### 修改文件的属性与权限

- chgrp: 修改文件所属的用户组
- chown: 修改文件拥有者
- chmod: 修改文件的权限, SUID、SGID、SBIT等特性

#### chomd

Linux文件的基本权限有9个, 分别是拥有者(owner)、所属群组(group)、其他人(others)三种身份各有自己的读(read)、写(write)、执行(execute)权限. 文件的权限字符为: [-rwxrwxrwx], 这九个权限是三个三个一组的。其中我们可以通过数字代表各个权限:

```bash
r:4
w:2
x:1
```

每种身份(owner、group、others)各自的三个权限(r、w、x)数字是需要累加的, 例如当权限为: [-rwxrw-r--]时:

```bash
owner = rwx = 4 + 2 + 1 = 7
group = rw- = 4 + 2 + 0 = 6
others = r-- = 4 + 0 + 0 = 4
```

所以该文件的权限是764, 修改权限的命令chmod的语法是:

```bash
chmod [-R] xyz 文件或目录

例如: chmod 777 .bashrc

xyz: 就是刚刚提到的数字类型的权限属性, 为rwx属性的数值的相加.
-R: 进行递归(recursive)修改, 亦即连同子目录下的所有文件都会修改.
```

### 目录与文件的权限意义

#### 权限对文件的意义

- r(read): 可读此文件的实际内容, 如读取文本文件的文字内容等.
- w(write): 可以编辑、新增或是修改该文件的内容(但不含删除该文件).
- x(excute): 该文件具有可以被系统执行的权限.

#### 权限对目录的意义

- r(read contents in directory): 表示具有读取目录结构列表的权限, 所以当你具有读取(r)一个目录的权限时, 表示你可以查询该目录下的文件名数据, 所以你就可以利用ls(或者ll)这个命令将该目录的内容列表显示出来.
- w(modify contents of directory): 表示你具有改动该目录结构列表的权限, 即包含以下权限
  
> - 建立新的文件与目录
> - 删除已经存在的文件与目录
> - 将已存在的文件或目录进行更名
> - 移动该目录内的文件、目录位置

- x(access directory): 目录的x代表的是用户能否进入该目录称为工作目录的用途, 也就是能否用cd命令进入该目录.

## 3. 文件与目录管理

### 目录与路径

#### 绝对路径与相对路径

- 绝对路径: 由根目录(/)开始写起的文件名或目录名称, 例如/home/test/.bashrc.
- 相对路径: 相对于当前路径的文件名写法, 如./home/test 或 ../../home/test, 其中./代表当前目录, ../代表上一层目录

#### 处理目录相关的常见命令

- cd: 切换目录
- pwd: 显示当前目录
- mkdir: 建立一个新目录
- rmdir: 删除一个空目录

#### 执行文件路径的变量: $PATH

```bash
# 打印出$PATH执行文件路径
# 会发现多个路径之间是用:分隔
echo $PATH
/usr/local/sbin:usr/local/bin:/sbin

# 添加新的路径
PATH="${PATH}:/root/new"
```

如果一个指令存在于多个执行文件路径中, 那先被查询到的路径中的命令会先执行

- 不同身份的用户默认的PATH不同, 默认能够随意执行的命令也不同;
- PATH是可以修改的;
- 命令应该放置在正确的目录下, 执行才会比较方便

### 文件与目录管理

#### 常见命令

- ls: 查看文件与目录(输入文件的话, 只会返回文件名)
- cp: 复制文件会目录
- rm: 删除文件或目录
- mv: 移动文件与目录, 或重命名

#### cp(复制文件需要关注的点)

- 是否需要完整的保留源文件的信息?
- 源文件是否为符号链接文件(symbolic link file)?
- 源文件是否为特殊的文件, 例如FIFO、socket等?
- 源文件是否为目录?

#### 获取路径的文件名与目录名

```bash
# 获取文件名
basename /etc/sysconfig/network
network

# 获取路径名
dirname /etc/sysconfig/network
/etc/sysconfig
```

### 文件内容的查看

#### 查看(读取)文件的常见命令

- cat: 由第一行开始显示文件内容
- tac: 从最后一行开始显示, 可以看出tac是cat的倒着写
- nl: 显示的时候, 同时输出行数
- more: 一页一页地显示文件内容
- less: 与more类似, 但是比more更好的是, 它可以往前翻页
- head: 只看前面几行
- tail: 只看后面几行
- od: 以二进制的方式读取文件内容

#### touch(修改文件时间或创建新文件)

touch 主要用于以下功能:

- 建立一个空文件
- 将某个文件日期自定义为目前(mtime与atime)

#### 文件的时间参数

- 修改时间(modification time, mtime): 当该文件的【内容数据】变更时, 就会更新这个时间, 内容数据指的是文件的内容, 而不是文件的属性或权限。
- 状态时间(status time, ctime): 当该文件的【状态(status)】改变时, 就会更新这个时间, 举例来说, 像是权限与属性被更改了, 都会更新这个时间。
- 读取时间(access time, atime): 当【该文件的内容被读取】时, 就会更新这个读取时间(access), 举例来说, 我们使用cat去读取/etc/man_db.conf, 就会更新该文件的atime。

### 文件与目录的默认权限与隐藏权限

#### 相关的常见命令

- umask: 指定当前用户在建立文件或目录时候的权限默认值
- chattr: 配置文件的隐藏属性
- lsattr: 显示文件隐藏属性

#### 文件特殊权限: SUID、SGID、SBIT

##### SUID

SUID是Set UID的简称, SUID有以下的限制与功能

- SUID权限仅对二进制程序(binary program)有效
- 执行者对于该程序需要具有x的可执行权限
- 本权限仅在执行该程序的过程中有效(run-time)
- 执行者将具有该程序拥有者(owner)的权限
- SUID仅可用在二进制程序上, 不能够用在shell脚本上面

##### SGID

SGID是Set GID的简称, 与SUID不同的是, SGID可以针对文件或目录来设置。如果是对文件来说, SGID有如下的功能:

- SGID对二进制程序有用
- 程序执行者对于该程序来说, 需具备x的权限
- 执行者在执行的过程中将会获得该程序用户组的支持

当一个目录设置了SGID的权限后, 它将具有如下功能:

- 用户若对于此目录具有r与x的权限时, 该用户能够进入此目录
- 用户在此目录下的有效用户组(effective group)将会变成该目录的用户组
- 用途：若用户在此目录下具有w的权限(可以新建文件), 则该用户所建立的新文件的用户组与此目录的用户组相同

##### SBIT

SBIT是Sticky Bit的简称, SBIT只对目录有效, 对于文件已经没有效用了, 其对于目录的作用是:

- 当用户对于此目录具有w、x权限, 即具有写入的权限
- 当用户在该目录下建立文件或目录时, 仅有自己与root才有权力删除该文件

##### SUID/SGID/SBIT权限的设置

- 4为SUID
- 2为SGID
- 1为SBIT

#### 观察文件类型

file为观察文件类型的常用指令

```bash
file ~/.bashrc
/root/.bashrc: ASCII text # 告诉我们是ASCII的纯文本文件

file /var/lib/mlovate/mlocate.db
/var/lib/mlovate/mlocate.db: data # 这是data文件
```

### 命令与文件查找

#### 相关的常见命令

- which: 用于查找命令, 这个命令是根据【PATH】这个环节变量所规范的路径, 去查找执行文件的文件名, 只能找出执行文件
- whereis: 在特定目录(主要针对/bin、/sbin下面的执行文件以及/usr/share/man下面的man page文件)中查找文件
- locate：查找文件, locate寻找的数据是由已建立的数据库/var/lib/mlocate/里面的数据所查找到的, 所以不用直接再去找硬盘, 速度很快
- find: 搜索硬盘内的文件名, 查找过程的时候非常消耗硬盘资源, 速度会很慢, 不过能找到的文件比较全, 这个是查找文件的兜底命令, 应该优先使用更快的查找命令

#### where

```bash
# 查找ls可执行命令
which ls
alias ls='ls --color=auto'
/bin/ls

# 查找history, 因为history是bash内置命令, which默认是找PATH内所置目录, 所以找不到
which history
/usr/bin/which: no history in (/sbin:/bin/:/usr/sbin:/usr/bin)
```

#### locate

locate命令的相关数据库的建立默认是在每天执行一次, 所以新建的文件在数据库建立之前可能找不到, 需要更细数据库.

- updatedb: 根据etc/updatedb.conf的设置去查找系统硬盘内的文件, 并更新/var/lib/mlocate内的数据库文件;
- locate: 依据/var/lib/mlocate/内的数据库记录, 找出用户所输入关键词的文件名

## 4. 磁盘与文件系统管理

### 4.1 Linux文件系统概要

#### 4.1.1 文件系统特性

Windows98以前主要使用的文件系统是FAT, Windows以后则主要使用NTFS. Linux则主要使用ext2、ext3、ext4.

ext2/3文件系统是索引式文件系统; FAT的文件系统则类似链表结构, 每个数据区块带有指针指向下一个数据区块.

- 传统文件系统: ext2、minix、FAT(用vfat模块)、iso9660(光盘等)
- 日志式文件系统: ext3、ext4、ReiserFS、Windows NTFS、IBM's JFS、ZFS
- 网络文件系统: NFS、SMBFS

#### 4.1.2 Linux的ext2文件系统

ext2文件系统格式化的时候基本是区分多个区块群组(block group), 每个区块群组有六个主要内容：

1. 数据区块(data block)
2. inode表(inode table)
3. 超级区块(superblock)
4. 文件系统描述说明(filesystem description)
5. 区块对照表(block bitmap)
6. inode对照表(inode bitmap)

##### 数据区块(data block)

在ext2文件系统中所支持的区块大小有1k、2k及4k三种, ext2文件系统的数据区块主要有以下限制

- 原则上, 区块的大小与数量在格式化完就不能够再修改(除非重新格式化)
- 在每个区块最多只能够放置一个文件的数据
- 如果文件大于区块大小, 则一个文件会占用多个区块的数量
- 若文件小于区块, 则该区块的剩余容量就不能够再被使用了(磁盘空间浪费)

##### inode表(inode table)

inode记录的数据至少有以下这些

- 该文件的读写属性(read、write、excute)
- 该文件的拥有者与用户组(owner、group)
- 该文件的大小
- 该文件建立或状态改变的时间(ctime)
- 最近一次的读取时间(atime)
- 最近修改的时间(mtime)
- 定义文件的标识(flag)、如SetUID
- 该文件真正的内容指向(pointer)

inode的数量与大小也是在格式化时就已经固定了, 除此之外inode还有以下特点:

- 每个iNode大小均为128B(新的ext4与xfs可设置为256B)
- 每个文件都仅会占用一个inode而已
- 因此文件系统能够建立的文件数量与inode的数量有关
- 系统读取文件时需要先找到inode, 并分析inode所记录的权限与用户是否符合, 若符合才能够读取区块的内容
- inode记录一个数据区块要使用4B, inode记录区块号码的区域定义为12个直接、1个间接、1个双间接、1个三间接记录区.

##### 超级区块(superblock)

超级区块是记录整个文件系统相关信息的地方, 没有超级区块, 就没有这个文件系统, 它记录的信息主要有:

- 数据区块与inode的总量
- 未使用与已使用的inode与数据区块数量
- 数据区块与inode的大小(block为1、2、4k, inode为128B或256B)
- 文件系统的挂载时间、最近一次写入数据的时间、最近一次检验磁盘(fsck)的时间等文件系统的相关信息
- 一个有效位数值, 若此文件系统已被挂载, 则有效位为0, 若未被挂载, 则有效位为1

##### 文件系统描述说明(filesystem description)

这个区段可以描述每个区块群组的开始与结束的区块, 以及说明每个区段(超级区块、对照表、inode对照表、数据区块)分别介于哪一个区块之间, 这部分也能够用dumpe2fs来观察

##### 区块对照表(block bitmap)

新增文件时总会用到区块, 那你要使用哪个区块来记录? 当然是选择空区块来记录新文件的数据. 那你怎么知道哪个区块是空的？这就要通过区块对照表的辅助, 从区块对照表当中可以知道哪些区块是空的， 系统能够快速的找到可使用的空区块来处理文件.

##### inode对照表(inode bitmap)

与区块对照表类似, inode对照表记录的使用与未使用的inode号码

##### dumpe2fs命令

dumpe2fs命令是一个查询ext系列超级区块信息的命令

#### 4.1.3 与目录树的关系

当我们在Linux下的文件系统建立一个目录时, 文件系统会分配一个inode与至少一块区块给该目录。其中, inode记录该目录的相关权限与属性, 并可记录分配到的那块区块号码. 而区块则是记录在这个目录下的文件名与该文件名占用的inode号码数据.

#### 4.1.4 ext2/ext3/ext4文件系统的文件存取

假设我们想要新增一个文件, 此时文件系统的操作是:

1. 先确定用户对于欲新增文件的目录文件的目录是否具有w与x的权限, 若有的话才能新增;
2. 根据inode对照表找到没有使用的inode号码, 并将新文件的权限、属性写入;
3. 根据区块对照表找到没有使用的区块号码, 并将实际的数据写入区块中, 且更新inode的区块指向数据;
4. 将刚刚写入的inode与区块数据同步更新inode对照表与区块对照表, 并更新超级区块的内容;

一般来说, 我们将inode表与数据区块称为数据存放区域, 其他例如超级区块、inode对照表、区块对照表等区段就被称为元数据(metadata).

##### 数据不一致与日志式文件系统

为了快速处理文件写入过程中出现的数据不一致的情况(例如写入过程中突然断电), 出现了日志式文件系统的解决方案:

1. 预备: 当系统要写入一个文件时, 会先在日志记录区块中记录某个文件准备写入的信息;
2. 实际写入: 开始写入文件的权限与数据, 开始更新metadata的数据;
3. 结束: 完后数据与meta的更新后, 在日志记录区块当中完成该文件的记录

ext3、4都是日志式文件系统

#### 4.1.5 Linux文件系统的运行

- 系统会将常用的文件数据放置到内存的缓冲区, 以加速文件系统的读写操作;
- 因此Linux的物理内存最后都会被用光, 这是正常的现象, 可加速系统性能;
- 若正常关机时, 关机命令都会主动调用sync来强制将内存中设置为Dirty的数据回写到磁盘中;
- 但若不正常关机(如断电、宕机等), 由于数据尚未回写到磁盘中, 因此重新启动后可能会花很多时间在进行磁盘校验, 甚至可能导致文件系统的损坏

#### 4.1.6 Linux VFS(virtual filesystem switch)

Linux支持多种文件系统, 都是通过一个名为VFS(virtual filesystem switch)的内核功能区读取文件系统. 也就是说, 整个Linux识别的文件系统其实都是VFS在进行管理, 我们用户并不需要知道每个硬盘分区上面的文件系统是什么, VFS会主动帮我们做好读取的操作, 抹平各个文件系统的差异.

#### 4.1.7 XFS文件系统简介

ext系列虽然支持度广, 但存在格式化超慢的问题. 因此从CentOS 7.x开始, 文件系统已经由默认的ext4变成了xfs这一个较适合高容量磁盘与巨型文件, 且性能佳的文件系统.

XFS文件系统中用xfs_info命令去观察超级区块内容, 类似于ext系列的dump2fs.

### 4.2 文件系统的简单操作

#### 4.2.1 磁盘与目录的容量

常用命令:

- df: 列出文件系统的整体磁盘使用量;
- du: 查看文件系统的磁盘使用量(常用在查看目录所占磁盘空间)

#### 4.2.2 硬链接和符号链接

##### 硬链接

- 硬链接的建立不消耗磁盘空间和inode, 硬链接只是在某个目录下新增一条文件名链接到mouinode号码的关联记录而已;
- 建立硬链接后, 如果你将任何一个文件名删除, 其实inode与区块都还是存在的, 此时你可以通过另一个文件名来读取到正确的文件数据;

硬链接的限制:

- 不能跨文件系统
- 不能链接目录

##### 符号链接

- 符号链接就是建立一个独立的文件, 而这个文件会让数据的读指向它链接的那个文件的文件名. 由于只是利用问价来做为指向的操作, 所以, 当源文件被删除后, 符号链接会报【无法打开某文件】(实际上就是找不到原始文件)
- 符号链接与Windows的快捷方式可以划上等号, 由符号链接所建立的文件为一个独立的新的文件, 所以会占用inode与区块

##### 相关命令

```bash
# 建立链接的命令
ln [-sf] 源文件 目标文件
# 选项与参数
#-s: 如果不加任何参数就进行链接, 那就是硬链接, 至于-s就是符号链接
#-f: 如果目标文件存在的话, 就主动的将目标文件直接删除后再建立

# 在/root目录下建立符号链接的例子
ln -s /etc/test test2
ll -i /etc/test /root/test2
# 打印结果
32424 -rw-r--r--. 2 root root 434 Jun 10 2011 /etc/test
23424 lrwxrwxrwx. 1 root root 12 Jun 23 22:23 /root/test2 -> /etc/test
```

### 4.3 磁盘的分区、格式化、检验与挂载

#### 4.3.1 相关常用命令

- lsblk: list block device的缩写, 作用是列出所有存储设备;
- blkid: 找出设备的UUID(universally unique identifier, 全局唯一标识符), 这个标识符可以拿来作为挂载或是使用这个设备或文件系统
- fdisk: MBR分区表分区
- gdisk: GPT分区表分区
- mkfs.xfs: 格式化为xfs文件系统
- mkfs.ext4: 格式化为ext4文件系统
- xfs_repair: XFS文件系统发生错乱时(如出现突然断电等), 进行文件系统校验(注意: 通常只有身为root且你的文件系统有问题的时候才使用这个命令, 否则在正常状况下使用此命令, 可能会造成对系统的危害, 通常使用这个命令的场合都是在系统出现极大的问题, 导致你在Linux启动的时候得进入单人单机模式下进行维护的操作时, 才必须使用此命令)
- fsck.ext4: ext4文件系统发生错乱时(如出现突然断电等), 进行文件系统校验(注意项同上)
- mount: 挂载磁盘分区(文件系统)
- 
- unmount: 卸载磁盘分区(文件系统)

#### 4.3.2 文件系统的挂载与卸载

文件系统的挂载点是目录, 而这个目录时进入磁盘分区(其实是文件系统)的入口, 在进行挂载前, 需要确定几件事:

- 单一文件系统不应该被重复挂载在不同的挂载点(目录)中;
- 单一的目录不应该重复挂载多个文件系统;
- 要作为挂载点的目录, 理论上应该都是空目录才行;
- 如果你要用来挂载的目录里面不是空, 那么挂载了新的文件系统之后, 原目录下的东西会暂时的隐藏, 等到这个新磁盘分区(文件系统)被卸载之后, 这个目录下原本的内容才会再次出现

#### 4.4 内存交换区

以前的年代内存不足, 因此那个可以将内存中的数据拿到硬盘中暂时存放的内存交换区(swap)就显得非常重要. 现在的主机内存虽然变大了不少, 但面对大型服务的时候, 预留内存交换分区来缓冲系统的内存使用量还是很重要的.

建立内存交换分区有以下方式:

- 设置一个内存交换分区
- 建立一个虚拟内存的文件

## 5. 文件与文件系统的压缩

### 5.1 Linux系统常见的压缩命令

#### 5.1.1 常见压缩文件

- *.Z: compress程序压缩的文件;
- *.zip: zip程序压缩的文件;
- *.gz: gzip程序压缩的文件;
- *.bz2: bzip2程序压缩的文件;
- *.tar: tar程序打包的文件, 并没有压缩过;
- *.tar.gz: tar程序打包的文件, 并且经过gzip的压缩;
- *.tar.bz2: tar程序打包的文件, 并且经过bzip2的压缩;
- *.tar.xz: tar程序打包的文件, 并且经过xz的压缩;

#### 5.1.2 gzip, zcat/zmore/zless/zgrep

gzip可以说是最应用最广的压缩命令了, 目前gzip可以解开compress、zip与gzip等软件所压缩的文件.当你使用gzip进行压缩时, 在默认的状态下原本的文件会被压缩成为.gz后缀的文件, 源文件就不再存在了, 这点与Windows的使用习惯有所不同.

cat/more/less 可以使用不同的方式来读取纯文本文件, 那zcat/zmore/zless则可以对应于cat/more/less的方式来读取纯文本文件被压缩后的压缩文件.另外, 如果你还想要从文字压缩文件当中找数据的话, 可以通过zgrep来查找关键词, 而不需要将压缩文件解开才以grep进行.

#### 5.1.3 bzip2, bzcat/bzmore/bzless/bzgrep

bzip2是压缩比比gzip还要好的压缩方式, 相关命令的用法也和gzip一样

#### 5.1.4 xz, xzcat/xzmore/xzless/xzgrep

xz这个压缩方式的压缩比比gzip和bzip2还要高, 相关命令的用法也和gzip一样

### 5.2 打包命令: tar

简单的使用例子

- 压缩: tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称;
- 查询: tar -jtv -f filename.tar.bz2;
- 解压缩: tar -jxv -f filename.tar.bz2 -C 的欲解压缩的目录;

### 5.3 XFS文件目录的备份与还原

#### 5.3.1 XFS文件系统备份xfsdump

xfsdump可以对xfs文件系统进行完整备份和增量备份, 在使用xfsdump的过程中主要有以下限制:

- xfsdump不支持没有挂载的文件系统备份, 所以只能备份已挂载的文件系统;
- xfsdump必须使用root的权限才能操作(涉及文件系统的关系);
- xfsdump只能备份xfs文件系统;
- xfsdump备份下来的数据(文件或存储媒介)只能让xfsrestore解析;
- xfsdump是通过文件系统的UUID来辨别各备份文件, 因此不能备份两个具有相同UUID的文件系统

#### 5.3.2 XFS文件系统还原xfsrestore

xfsdump的恢复使用的是xfsrestore这个命令.

## 6. vim程序编辑器

### 6.1 vi与vim

vi是UNIX-like系统中的老式编辑器(但功能很齐全), 很多软件的编辑接口都会主动调用vi.vim可以视作是vi的高级版本, vim可以用颜色或下划线的方式来显示一些特殊的信息.

### 6.2 vi的使用

vi共有3种模式：

- 一般命令模式
- 编辑模式
- 命令模式

一般命令模式可与编辑模式及命令行模式切换, 但编辑模式与命令行模式之间不可互相切换.

#### 6.2.1 一般命令模式

以vi打开一个文件就直接进入一般命令模式(这是默认的模式, 也简称为一般模式). 在这个模式中, 你可以使用【上下左右】按键来移动光标, 你可以使用【删除字符】或【删除整行】来处理文件内容, 也可以使用【复制、粘贴】来处理你的文件内容.

#### 6.2.2 编辑模式

在一般命令模式中可以进行删除、复制、粘贴等的操作, 但是却无法编辑文件的内容. 要等到你按下【i、I、o、O、a、A、r、R】等中任何一个字母之后才会进入编辑模式. 通常在Linux中, 按下这些按键时, 在界面的左下方会出现【INSERT】或【REPLACE】的字样, 此时才可以进行编辑, 如果要回到一般命令模式, 按下【Esc】这个按键即可退出编辑模式.

#### 6.2.3 命令行模式

在一般模式当中, 输入【:/?】三个中的任何一个按钮, 就可以将光标移动到最下面那一行. 在这个模式当中, 可以提供你【查找数据】的操作, 而读取、保存、批量替换字符、退出vi、显示行号等的操作也是在此模式中完成.

## 7. 认识和学习bash

### 7.1 认识bash这个shell

#### 7.1.1 查询命令是否为Bash shell的内置命令: type

```bash
type [-tpa] name
  : 不加任何参数时, type会显示出name是外部命令还是bash内置命令;
-t: 当加入-t参数时, type将name以下面这些字眼显示出它的意义：
    file: 表示外部命令;
    alias: 表示该命令为命令别名所设置的名称;
    builtin: 表示该命令为bash内置的命令功能;

-p: 如果后面接的name是外部命令时, 才会显示完整文件名;
-a: 会用PATH变量定义的路径中, 将所有含name的命令都列出来, 包含alias;
```

### 7.2 shell的变量功能

#### 7.2.1 变量的使用与设置: echo、变量设置规则、unset

变量的设置规则：

- 变量与变量内容以一个等号【=】来连接;

```bash
myname=mathe
```

- 等号两边不能直接接空格;

```bash
# 以下示例都是错的
myname = mathe 或 myname=mat he
```

- 变量名称只能是英文字母与数字, 但是开头字符不能是数字;

```bash
# 以下示例是错的
2myname=mathe
```

- 变量内容若有空格可使用双引号【"】或者单引号【'】将变量内容包裹结合起来;
- 双引号内的特殊字符如$等, 可以包有原本的特性;

```bash
var="$myname is a boy"
echo $var # 打印出来是mathe is a boy
```

- 单引号内的特殊字符则仅为一般字符(纯文本);

```bash
var='$myname is a boy'
echo $var # 打印出来是$myname is a boy
```

- 可用转义符【\】将特殊符号(如[Enter]、$、\、空格等)变成一般字符, 如:

```bash
myname=mat\ he
echo $myname # 打印出来是mat he
```

- 在一串命令的执行中, 还需要借由其他命令所提供的信息时, 可以使用反单引号【`】或【$(命令)】;

```bash
version=$(uname -r)
echo $version # 打印出来是3.10.0-229.el7.x86-64
```

- 若该变量需要在其他子程序执行, 则需要以export来使变量变成环境变量;

```bash
export PATH
```

- 若该变量为扩增变量内容时, 则可用"$变量名称"或${变量}累加内容;

```bash
PATH="$PATH":/home/bin或PATH=${PATH}:/home/bin
```

- 通常大写字符为系统默认变量, 自行设置变量可以使用小写字符;

- 取消变量的方法为使用unset: 【unset 变量名称】：

```bash
myname=mathe
echo $myname # 打印出来是mathe
unset myname
echo $myname # 打印出来是空
```

#### 7.2.2 环境变量的功能

常见的相关指令:

- env: 列出所有的环境变量;
- set: 列出所有的环境变量以及bash操作界面有关的变量

常见的环境变量:

- HOME: 代表用户的根目录;
- SHELL: 代表目前的环境使用的SHELL是哪个程序? Linux默认使用/bin/bash;
- MAIL: 当我们使用mail这个命令在收信时, 系统会去读取的邮箱文件(mailbox);
- PATH: 执行文件查找的路径, 目录与目录中间用冒号(:)分隔;
- LANG: 语系数据;
- RANDOM: 随机数变量, 可以通过($RANDOM)来获取一个0~32767的随机数值;
- $: 关于本shell的PID(process id);
- ?: 获取上个命令执行的返回值;


#### 7.2.3 变量键盘读取、数组与声明

常见的相关指令:

- read: 可以用来读取来自键盘输入的变量;
- declare: 声明变量类型, 不声明的情况下, 变量类型默认是字符串;
- typeset: 用法和declare类似;

#### 7.2.4 与文件系统及程序的限制关系: ulimit

Linux主机可以同时登陆多个人, 如果每个人都开启多个大文件, 主机内存会不够用, 肯定很容易挂, 所以需要限制一下每个用户所使用的系统资源, 这就需要通过ulimit命令.

#### 7.2.5 变量内容的删除、取代与替换

| 变量设置方式 | 说明 |
| ----------- | ---- |
| ${变量#关键词} | 若变量内容从头开始的数据符合【关键词】, 则将符合的最短数据删除 |
| ${变量##关键词} | 若变量内容从头开始的数据符合【关键词】, 则将符合的最长数据删除 |
| ${变量%关键词} | 若变量内容从尾向前的数据符合【关键词】, 则将符合的最短数据删除 |
| ${变量%%关键词} | 若变量内容从尾向前的数据符合【关键词】, 则将符合的最长数据删除 |
| ${变量/旧字符/新字符} | 若变量内容符合【旧字符串】则【第一个旧字符串会被新字符串替换】 |
| ${变量//旧字符/新字符} | 若变量内容符合【旧字符串】则【全部的旧字符串会被新字符串替换】 |

| 变量的设置方式 | str没有设置 | str为空字符串 | str已设置非空字符串 |
| ------------ | ----------- | ------------ | ------------------ |
| var=${str-expr} | var=expr | var=  | var=$str |
| var=${str:-expr} | var=expr | var=expr  | var=$str |
| var=${str+expr} | var= | var=expr  | var=$expr |
| var=${str:+expr} | var= | var=  | var=$expr |
| var=${str=expr} | str=expr var=expr | str不变 var= | str不变 var=$str |
| var=${str:=expr} | str=expr var=expr | str=expr var=expr | str不变 var=$str |
| var=${str?expr} | expr输出值stderr | var= | var=$str |
| var=${str:?expr} | expr输出值stderr | expr输出值stderr | var=$str |

### 7.3 命名别名与历史历史


- alias: 设置命令别名;
- unalias: 取消别名设置;
- history: 查询曾经执行过的命令;

```bash
# 设置别名
alias lm='ls -al | more'

# 直接不加参数调用则是列出所有别名
alias

# 取消别名
unalias lm
```

### 7.4 Bash shell的操作环境

#### 7.4.1 命令行运行的查找执行顺序

1. 以相对/绝对路径执行命令, 例如【/bin/ls】或【./ls】;
2. 由alias找到该命令来执行;
3. 由bash内置的(builtin)命令来执行;
4. 通过$PATH这个变量的顺序查找到的附一个命令来执行;

#### 7.4.2 bash的环境配置文件

相关命令:

- source: 读入环境配置文件的命令;

```bash
# 将家目录~/.bashrc的设置读入目前的bash环境中
source ~/.bashrc

# 作用同上
. ~/.bashrc
```

bash在读完了整体环境设置的/etc/profile并借此调用其他配置文件后, 接下来则是会读取用户的个人配置文件. 在login shell的bash环境中, 所读取的个人配置文件其实主要有三个, 读取顺序依次是:

- ~/.bash_profile
- ~/.bash_login
- ~/.profile

#### 7.4.3 终端的环境设置: stty、set

常见命令:

- stty: 设置终端的输入按键带边的意义, 如果加上参数【-a】, 则是列出目前环境中的所有按键列表;
- set: 设置bash中的一些终端设置值;

### 7.5 数据流重定向

#### 7.5.1 什么是数据流重定向

传送所用的特殊字符如下:

- 标准输入(stdin): 代码为0, 使用< 或 <<;
- 标准输出(stdout): 代码为1, 使用> 或 >>;
- 标准错误输出(stderr): 代码为2, 使用2> 或 2>>;

```bash
# 此时屏幕会显示出文件名信息
ll /

# 屏幕并无任何信息
ll / > ~/rootfile

# 记录文件被新建, 屏幕会打印出该文件名相关信息
ll ~/rootfile
```

以上例子的文件建立规则是:

- 该文件(本例中是~/rootfile)若不存在, 系统会自动地将他建立起来;
- 当这个文件存在的时候, 那么系统就会先将这个文件内容清空, 然后再将数据写入;
- 也就是若以>输出到一个已存在的文件中, 这个文件就会被覆盖掉.

- 1>: 以覆盖的方法将【正确的数据】输出到指定的文件或设备上;
- 1>>: 以累加的方法将【正确的数据】输出到指定的文件或设备上;
- 2>: 以覆盖的方法将【错误的数据】输出到指定的文件或设备上;
- 2>>: 以累加的方法将【错误的数据】输出到指定的文件或设备上;

#### 7.5.2 命令执行的判断根据

;: 执行多个命令用;(分号)分隔;
&&: 与执行多个命令;
||: 或执行多个命令;

```bash
# 执行多个命令
cmd1; cmd2; cmd3

# 与执行多个命令, 当cmd1执行完毕且正确执行(命令返回值$?=0)的时候, 才会执行cmd2
cmd1 && cmd2

# 或执行多个命令, 当cmd1执行完毕且为错误(命令返回值$?<>0)的时候, 才会执行cmd2
cmd1 || cmd2
```

### 7.6 管道命令(pipe)

#### 7.6.1 相关常用命令:

- cut: 将输入数据进行分割;
- grep: 分析输入数据中的每行信息, 若当中有我们所需要的信息, 就将该行拿出来;
- sort: 对输入数据进行排序;
- uniq: 对输入数据进行去重, 重复的行只显示一条;
- wc: 显示输入数据中有多少字? 多少行? 多少字符?
- tee: 同时将输入的数据流分送到文件与屏幕(screen);
- tr: 可以用来删除一段信息当中的文字, 或是进行文字信息的替换;
- col: 可以用来简单地处理将【tab】按键替换成为空格键;
- join: 两个文件当中, 有相同数据的那一行, 才将它加在一起;
- paste: 直接将两行贴在一起, 且中间以【tab】键隔开;
- expand: 将【tab】键转成空格键;
- split: 将一个大文件划分成为小文件;
- xargs: 可以读入stdin的数据, 并且以空格符或换行符作为标识符, 将stdin的数据分隔成为参数;

#### 7.6.2 关于减号【-】的用途

在管道命令中, 常常会使用到前一个命令的stdout作为这次的stdin, 某些命令需要用到文件名(例如 tar)来进行处理时, 该stdin与stdout可以利用减号'-'来替代.

## 8. 正则表达式与文件格式化处理

### 8.1 基础正则表达式

#### 8.1.1 正则表达式中的特殊符号

| 特殊符号 | 代表意义 |
| ------- | -------- |
| [:alnum:] | 代表英文大小写字符及数字, 亦即0~9、A~Z、a~z |
| [:alpha:] | 代表英文大小写字符, 亦即A~Z、a~z |
| [:blank:] | 代表空格键与【Tab】按键两者 |
| [:cntrl:] | 代表键盘上面控制按键, 包括CR、LF、Tab、Del等 |
| [:digit:] | 代表数字, 0~9 |
| [:graph:] | 代表除了空格符(空格键与【Tab】按键)外的其他所有按键 |
| [:lower:] | 代表小写字符, 即a~z |
| [:upper:] | 代表大写字符, 即A~Z |
| [:print:] | 代表任何可以打印出来的字符 |
| [:punct:] | 代表标点符号(punctuation symbol)， 亦即: "'?!:;#$等 |
| [:space:] | 代表任何会产生空白的字符, 包括空格、【Tab】、CR等 |
| [:xdigit:] | 代表十六进制的数字类型, 因此包括0~9、A~F、a~f的数字与字符 |

#### 8.1.2 sed工具

sed本身是一个管道命令, 可以分析标准输入, 可以将数据进行替换、删除、新增、选取特定行等功能.

### 8.2 文件的格式化与相关处理

#### 8.2.1 格式化打印: printf

printf可以对输入的文件内容进行格式化打印

```bash
printf '打印格式' 实际内容
```

#### 8.2.2 awk: 好用的数据处理工具

awk相当适合处理小型的文本数据, awk主要是处理每一行的字段内的数据, 而默认的字段的分隔符为"空格键"或"tab键".

```bash
awk '条件类型1{操作1} 条件类型2{操作2} ...' filename
```

#### 8.2.3 文件对比工具

- diff: diff通常是用在同一个文件(或软件)的新旧版本差异上. diff也可以比对整个目录下的差异;
- cmp: cmp主要也是在比对两个文件, 它主要利用字节单位去比对, 因此, 也可以比对二进制文件;
- patch: patch这个命令与diff密不可分, diff可以产生差异文件(补丁包), 然后通过patch命令将补丁包更新;


## 9. 学习shell脚本

### 9.1 什么是shell脚本

#### 9.1.2 shell脚本的编写

1. 第一行#!/bin/bash 用来声明这个脚本使用的shell名称;
2. 程序内容的说明;
3. 主要环境变量的声明;
4. 主要程序部分;
5. 执行结果告知(定义返回值), 成功exit 0, 其他情况exit n(n是数字);

### 9.2 编写shell脚本

本节实战比较多, 建议直接看书.

## 10. Linux账号管理与ACL权限设置

### 10.1 Linux的账号与用户组

#### 10.1.1 用户标识符: UID与GID

每个用户登录至少都会获取到两个ID, 一个是用户ID(User ID, 简称UID), 一个是用户组ID(Group ID, 简称GID). 当我们有显示文件属性的需求时, 系统会根据/etc/passwd与/etc/group的内容, 找到UID与GID对应的账号与组名再显示出来.

#### 10.1.2 用户账号

在你输入账号密码登录Linux的过程中, 系统做了以下事情:

1. 先查找/etc/passwd里面是否有你输入的账号?如果没有则退出, 如果有的话则将该账号对应UID与GID(在/etc/group中)读出来, 另外, 该账号的家目录与shell设置也一并读出.
2. 再来则是核对密码表. 这是Linux会进入/etc/shadow里面找出对应的账号与UID, 然后核对一下你刚刚输入的密码与里面的密码是否相符.
3. 如果一切都OK得话, 就进入shell管理的阶段.

```bash
# 输出/etc/passwd的第一行数据
head -n 1 /etc/passwd

# 打印结果
root:x:0:0:root:/root:/bin/bash
```

打印出来的每行共有7个重要内容, 每个内容之间用:分隔, 他们分别是:

1. 账号名称;
2. 账号密码, 为了安全性, 密码数据都改放在/etc/shadow中, /etc/passwd中打印出来都是【x】;
3. UID, 用户标识符;
4. GID, 用户组标识符;
5. 用户信息说明栏, 没什么重要用途, 只是用来解释这个账号的意义;
6. 家目录, 用户的家目录;
7. shell, 用户的默认shell;

#### 10.1.3 关于用户组

```bash
# 输出/etc/group 的第一行数据
tail -n 1 /etc/group

# 打印结果
mat:x:1000:mat
```

打印出来的每行共有4个主要内容, 每个内容之间用:分隔, 他们分别是:

1. 组名;
2. 用户组密码, 为了安全性, 密码数据都改放在/etc/gshadow中, /etc/group 中打印出来都是【x】;
3. GID, 用户组ID;
4. 此用户组支持的账号名称;

相关命令:

groups: 列出当前用户所有支持的用户组, 其中第一个为有效用户组(effective group).
newgrp: 切换有效用户组, 切换的有效用户组必须是当前用户所支持的用户组.

```bash
# 打印出当前用户所支持的用户组
groups

# 打印值, 说明当前的有效用户组是mat, 即如果我现在去新建文件, 是以mat这个用户组的身份去建立的
mat wheel

# 切换有效用户组
newgrp wheel
```

### 10.2 账号管理

#### 10.2.1 新增与删除用户

相关命令:

useradd: 添加新用户;
passwd: 修改账号密码;
change: 修改密码参数, 可以做到【用户第一次登陆时, 强制他们一定要修改密码后才能够使用系统资源】
usermod: 修改用户参数;
userdel: 删除用户;

```bash
useradd [-u UID] [-g 初始用户组] [-G 次要用户组] [-mM] [-c 说明栏] [-d 家目录绝对路径] [-s shell] 使用者账号

# 修改当前账户密码
passwd

# 修改某个账户的密码
passwd mat
```

在使用useradd添加账号的过程中, Linux系统帮我们处理了以下事情:

- 在etc/passwd里面建立一行与账号相关的数据, 包括建立UID/GID/家目录等;
- 在etc/shadow里面将此账号的密码相关参数写入, 但是尚未有密码;
- 在etc/group里面加入一个与账号名称一模一样的组名;
- 在/home下面家里一个与账号同名的目录作为用户家目录, 且权限为700.
- 由于/etc/shadow内仅会有密码参数而不会有加密过的密码数据, 因此我们在建立用户账号时, 还需要使用【passwd 账号】这个命令来设置密码才算是完成了用户建立的流程.

#### 10.2.2 用户功能

相关命令

- id: 可以查询某人或自己相关UID/GID等消息;
- finger: 列出用户的相关属性, 列出来的几乎都是/etc/passwd文件里面的东西;
- chfn: 有点像change finger的意思, 用来修改你【个人属性】;
- chsh: change shell的简写, 改变用户的默认shell;

#### 10.2.3 新增与删除用户组

相关命令

- groupadd: 新建用户组;
- groupmod: 修改用户组的相关参数;
- groupdel: 删除用户组;
- gpasswd: 设置用户组密码或者设置用户组管理员;

#### 10.3 主机的详细权限规划: ACL的使用

ACL 是 Access Control List的英文缩写, 中文译为访问控制列表, 主要目的是提供传统的属主、所属群组、其他人的读、写、执行之外的详细权限设置. ACL可以针对单一用户、单一文件或目录来进行r、w、x的权限设置, 对于需要特殊权限的使用状况非常有帮助.

### 10.4 用户身份的切换

#### 10.4.1 su

- 直接用【su username】切换身份的话, 读取的变量设置方式为非登录shell的方式, 这种方式很多原本的变量不会被修改, 尤其是PATH变量;
- 若要完整地切换到新用户的环境, 必须要使用【su - username】或【su -l username】, 才会连同PATH、USER、MAIL等变量都转成新用户的环境;
- 如果仅想要执行一次root的命令, 可以利用【su - -c "命令串"】的方式来处理;
- 使用root切换成为任何用户时, 并不需要输入新用户的密码.

#### 10.4.2 sudo

相对于su需要了解新切换的用户密码(常常是需要root的密码), sudo的执行则仅需要自己的密码即可. 甚至可以设置不需要密码即可执行sudo. 由于sudo可以让你以其他用户的身份执行命令(通常是使用root的身份来执行命令), 因此并非所有人都能够执行sudo, 而是仅有规范到/etc/sudoers内的用户才能够执行sudo这个命令.

```
sudo [-b] [-u 新使用者的账号]
选项与参数
-b: 将后面的命令放到后台中让系统自行执行, 而不与目前的shell产生影响;
-u: 后面可以接欲切换使用者, 若无此项则代表切换身份为root
```

sudo的执行流程如下:

1. 当用户执行sudo时, 系统于/etc/sudoers文件中查找该用户是否有执行sudo的权限;
2. 若用户具有可执行sudo的权限后, 便让用户【输入用户自己的密码】来确认;
3. 若密码输入成功, 便开始进行sudo后续接的命令(但root执行sudo时, 不需要输入密码);
4. 若欲切换的身份与执行者身份相同, 那也不需要输入密码.

### 10.5 Linux主机上的用户信息传递

#### 10.5.1 查询用户

相关命令

- w: 显示目前登录在系统上面的用户;
- who: 同上;
- last: 显示用户最近的登录信息;
- lastlog: 显示每个账号最近登录的时间, 该命令会去读取/var/log/lastlog文件, 并将数据输出.

#### 10.5.2 用户对谈

- write: 给Linux系统上的其他用户发送信息;
- mesg: 设置是否接收别的用户发送过来的信息, 不过对root发送过来的信息没有阻止的能力, 还是得接收;
- wall: 广播消息, 给在线的每个用户都发送消息;

```bash
# 发送消息
write 使用者账号 [使用者所在的终端界面]

# 设置禁止接收信息
mesg n

# 设置接收信息
mesg y

# 广播消息
wall 消息
```

## 11. 磁盘配额(Quota)与高级文件系统管理

## 12. 计划任务

Linux的计划任务主要有两种:
at: 处理仅执行一次就结束的任务;
crontab: 处理循环任务, 所设置的任务会一直循环执行下去;

### 12.1 仅执行一次的计划任务

执行at时, 必须要有atd这个服务的支持才行.

#### 12.1.1 atd的启动与at运行方式

```bash
# 重新启动atd这个服务
systemctl restart atd

# 让这个服务开机就自动启动
systemctl enable atd

# 查看一下atd目前的状态
systemctl status atd
```

at命令涉及到系统安全问题, 应该严格控制命令的使用权限, 可以利用/etc/at.allow与/etc/at.deny这两个文件来实现对at的使用限制:

1. 调用at过程中, 系统会先找寻/etc/at.allow这个文件, 写在这个文件中的用户才能使用at, 没有在这个文件中的用户则不能使用at(即使没有写在at.deny当中);
2. 如果/etc/at.allow不存在, 就查找/etc/at.deny这个文件, 写在这个/etc/at.deny中的用户则不能使用at, 而没有在这个at.deny文件中的用户, 就可以使用at;
3. 如果这两个文件都不存在的话, 那么只有root用户可以使用at这个命令;

#### 12.1.2 实际运行单一计划任务

相关命令:

atq: 列出所有at计划任务, 类似at -l;
atrm: 删除对应任务id的at计划任务;
batch: 系统有空时才执行后台任务, 它是在CPU的任务负载小于0.8的时候, 才执行你的工作任务;

### 12.2 循环执行的计划任务

#### 12.2.1 用户的设置

crontab命令涉及到系统安全问题, 应该严格控制命令的使用权限, 可以利用/etc/cron.allow与/etc/cron.deny这两个文件来实现对at的使用限制:

1. 调用crontab过程中, 系统会先找寻/etc/cron.allow这个文件, 写在这个文件中的用户才能使用 crontab, 没有在这个文件中的用户则不能使用crontab(即使没有写在cron.deny当中);
2. 如果/etc/cron.allow不存在, 就查找/etc/cron.deny这个文件, 写在这个/etc/cron.deny中的用户则不能使用crontab, 而没有在这个cron.deny文件中的用户, 就可以使用crontab;
3. 如果这两个文件都不存在的话, 那么只有root用户可以使用crontab这个命令;

#### 12.2.2 crontab任务系统配置文件

crond服务读取配置文件的位置主要有以下三个地方:

- /etc/crontab
- /etc/cron.d/*
- /var/spool/cron/*

#### 12.3 可唤醒停机期间的工作任务

anacron: anacron也是每小时被crond执行一次, 然后anacron再去检测相关的计划任务有没有被执行, 如果超过期限的任务在, 就执行该任务, 执行完毕或无需执行任何任务时, anacron就停止.

anacron的执行流程大概如下:

1. 由/etc/anacrontab分析到cron.daily这项任务名称的天数为1天;
2. 由/var/spool/anacron/cron.daily取出最近一次执行anacron的时间戳;
3. 又上个步骤与目前的时间比较, 若差异天数为一天以上(含1天), 就准备执行命令;
4. 若准备执行命令, 根据/etc/anacrontab的设置, 将延迟5分钟+3小时(看START_HOURS_RANGE的设置)
5. 延迟时间过后, 开始执行后续命令, 即【run-parts /etc/cron.daily】这串命令;
6. 执行完毕后, anacron程序结束.
