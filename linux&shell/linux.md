# Linux

## 1. 概要与杂项

### X Window与命令行模式的切换
  
X Window是窗口管理器环境, Linux最常用的是命令行界面(也叫终端界面、Terminal或者Console), Linux默认情况下会提供六个终端来让用户登录, 切换方式为使用: [Ctrl + Alt + F1~F6]的组合键, 系统会将[F1] ~ [F6] 命名为tty1 ~ tty6的操作接口环境。

### Linux在线求助

1. Linux所有命令都会有--help参数, 可以方便查看该命令的用法
2. 使用man命令, man是manual(操作说明)的简写, 使用man [command] 可以查看该command的说明.
3. 使用info命令, 使用info [command] 可以查看该command的说明, 但是与man一口气输出一堆信息不同的是, info page则是将文件数据拆成一个一个的段落, 每个段落用自己的页面来编写, 并且各个页面中还有类似网页的超链接来跳到各不同的页面中, 每个独立的页面也被称为一个节点. 所以, 你可以将info输出的info page想成是命令行模式的网页显示数据.

### 如何关机Linux

与关机有关的命令：

- sync: 将数据同步写入硬盘中
- shutdown: 关机
- halt: 系统停止, 屏幕可能会保留系统已经停止的信息
- poweroff: 系统关机, 所以没有提供额外的电力, 屏幕空白
- reboot: 重新启动
- suspend: 进入休眠模式

目前shutdown、reboot、halt等命令均会在关机前调用sync, 确保数据完整.

## 2. 权限与目录配置

### 修改文件的属性与权限

- chgrp: 修改文件所属的用户组
- chown: 修改文件拥有者
- chmod: 修改文件的权限, SUID、SGID、SBIT等特性

#### chomd

Linux文件的基本权限有9个, 分别是拥有者(owner)、所属群组(group)、其他人(others)三种身份各有自己的读(read)、写(write)、执行(execute)权限. 文件的权限字符为: [-rwxrwxrwx], 这九个权限是三个三个一组的。其中我们可以通过数字代表各个权限:

```bash
r:4
w:2
x:1
```

每种身份(owner、group、others)各自的三个权限(r、w、x)数字是需要累加的, 例如当权限为: [-rwxrw-r--]时:

```bash
owner = rwx = 4 + 2 + 1 = 7
group = rw- = 4 + 2 + 0 = 6
others = r-- = 4 + 0 + 0 = 4
```

所以该文件的权限是764, 修改权限的命令chmod的语法是:

```bash
chmod [-R] xyz 文件或目录

例如: chmod 777 .bashrc

xyz: 就是刚刚提到的数字类型的权限属性, 为rwx属性的数值的相加.
-R: 进行递归(recursive)修改, 亦即连同子目录下的所有文件都会修改.
```

### 目录与文件的权限意义

#### 权限对文件的意义

- r(read): 可读此文件的实际内容, 如读取文本文件的文字内容等.
- w(write): 可以编辑、新增或是修改该文件的内容(但不含删除该文件).
- x(excute): 该文件具有可以被系统执行的权限.

#### 权限对目录的意义

- r(read contents in directory): 表示具有读取目录结构列表的权限, 所以当你具有读取(r)一个目录的权限时, 表示你可以查询该目录下的文件名数据, 所以你就可以利用ls(或者ll)这个命令将该目录的内容列表显示出来.
- w(modify contents of directory): 表示你具有改动该目录结构列表的权限, 即包含以下权限
  
> - 建立新的文件与目录
> - 删除已经存在的文件与目录
> - 将已存在的文件或目录进行更名
> - 移动该目录内的文件、目录位置

- x(access directory): 目录的x代表的是用户能否进入该目录称为工作目录的用途, 也就是能否用cd命令进入该目录.

## 3. 文件与目录管理

### 目录与路径

#### 绝对路径与相对路径

- 绝对路径: 由根目录(/)开始写起的文件名或目录名称, 例如/home/test/.bashrc.
- 相对路径: 相对于当前路径的文件名写法, 如./home/test 或 ../../home/test, 其中./代表当前目录, ../代表上一层目录

#### 处理目录相关的常见命令

- cd: 切换目录
- pwd: 显示当前目录
- mkdir: 建立一个新目录
- rmdir: 删除一个空目录

#### 执行文件路径的变量: $PATH

```bash
# 打印出$PATH执行文件路径
# 会发现多个路径之间是用:分隔
echo $PATH
/usr/local/sbin:usr/local/bin:/sbin

# 添加新的路径
PATH="${PATH}:/root/new"
```

如果一个指令存在于多个执行文件路径中, 那先被查询到的路径中的命令会先执行

- 不同身份的用户默认的PATH不同, 默认能够随意执行的命令也不同;
- PATH是可以修改的;
- 命令应该放置在正确的目录下, 执行才会比较方便

### 文件与目录管理

#### 常见命令

- ls: 查看文件与目录(输入文件的话, 只会返回文件名)
- cp: 复制文件会目录
- rm: 删除文件或目录
- mv: 移动文件与目录, 或重命名

#### cp(复制文件需要关注的点)

- 是否需要完整的保留源文件的信息?
- 源文件是否为符号链接文件(symbolic link file)?
- 源文件是否为特殊的文件, 例如FIFO、socket等?
- 源文件是否为目录?

#### 获取路径的文件名与目录名

```bash
# 获取文件名
basename /etc/sysconfig/network
network

# 获取路径名
dirname /etc/sysconfig/network
/etc/sysconfig
```

### 文件内容的查看

#### 查看(读取)文件的常见命令

- cat: 由第一行开始显示文件内容
- tac: 从最后一行开始显示, 可以看出tac是cat的倒着写
- nl: 显示的时候, 同时输出行数
- more: 一页一页地显示文件内容
- less: 与more类似, 但是比more更好的是, 它可以往前翻页
- head: 只看前面几行
- tail: 只看后面几行
- od: 以二进制的方式读取文件内容

#### touch(修改文件时间或创建新文件)

touch 主要用于以下功能:

- 建立一个空文件
- 将某个文件日期自定义为目前(mtime与atime)

#### 文件的时间参数

- 修改时间(modification time, mtime): 当该文件的【内容数据】变更时, 就会更新这个时间, 内容数据指的是文件的内容, 而不是文件的属性或权限。
- 状态时间(status time, ctime): 当该文件的【状态(status)】改变时, 就会更新这个时间, 举例来说, 像是权限与属性被更改了, 都会更新这个时间。
- 读取时间(access time, atime): 当【该文件的内容被读取】时, 就会更新这个读取时间(access), 举例来说, 我们使用cat去读取/etc/man_db.conf, 就会更新该文件的atime。

### 文件与目录的默认权限与隐藏权限

#### 相关的常见命令

- umask: 指定当前用户在建立文件或目录时候的权限默认值
- chattr: 配置文件的隐藏属性
- lsattr: 显示文件隐藏属性

#### 文件特殊权限: SUID、SGID、SBIT

##### SUID

SUID是Set UID的简称, SUID有以下的限制与功能

- SUID权限仅对二进制程序(binary program)有效
- 执行者对于该程序需要具有x的可执行权限
- 本权限仅在执行该程序的过程中有效(run-time)
- 执行者将具有该程序拥有者(owner)的权限
- SUID仅可用在二进制程序上, 不能够用在shell脚本上面

##### SGID

SGID是Set GID的简称, 与SUID不同的是, SGID可以针对文件或目录来设置。如果是对文件来说, SGID有如下的功能:

- SGID对二进制程序有用
- 程序执行者对于该程序来说, 需具备x的权限
- 执行者在执行的过程中将会获得该程序用户组的支持

当一个目录设置了SGID的权限后, 它将具有如下功能:

- 用户若对于此目录具有r与x的权限时, 该用户能够进入此目录
- 用户在此目录下的有效用户组(effective group)将会变成该目录的用户组
- 用途：若用户在此目录下具有w的权限(可以新建文件), 则该用户所建立的新文件的用户组与此目录的用户组相同

##### SBIT

SBIT是Sticky Bit的简称, SBIT只对目录有效, 对于文件已经没有效用了, 其对于目录的作用是:

- 当用户对于此目录具有w、x权限, 即具有写入的权限
- 当用户在该目录下建立文件或目录时, 仅有自己与root才有权力删除该文件

##### SUID/SGID/SBIT权限的设置

- 4为SUID
- 2为SGID
- 1为SBIT

#### 观察文件类型

file为观察文件类型的常用指令

```bash
file ~/.bashrc
/root/.bashrc: ASCII text # 告诉我们是ASCII的纯文本文件

file /var/lib/mlovate/mlocate.db
/var/lib/mlovate/mlocate.db: data # 这是data文件
```

### 命令与文件查找

#### 相关的常见命令

- which: 用于查找命令, 这个命令是根据【PATH】这个环节变量所规范的路径, 去查找执行文件的文件名, 只能找出执行文件
- whereis: 在特定目录(主要针对/bin、/sbin下面的执行文件以及/usr/share/man下面的man page文件)中查找文件
- locate：查找文件, locate寻找的数据是由已建立的数据库/var/lib/mlocate/里面的数据所查找到的, 所以不用直接再去找硬盘, 速度很快
- find: 搜索硬盘内的文件名, 查找过程的时候非常消耗硬盘资源, 速度会很慢, 不过能找到的文件比较全, 这个是查找文件的兜底命令, 应该优先使用更快的查找命令

#### where

```bash
# 查找ls可执行命令
which ls
alias ls='ls --color=auto'
/bin/ls

# 查找history, 因为history是bash内置命令, which默认是找PATH内所置目录, 所以找不到
which history
/usr/bin/which: no history in (/sbin:/bin/:/usr/sbin:/usr/bin)
```

#### locate

locate命令的相关数据库的建立默认是在每天执行一次, 所以新建的文件在数据库建立之前可能找不到, 需要更细数据库.

- updatedb: 根据etc/updatedb.conf的设置去查找系统硬盘内的文件, 并更新/var/lib/mlocate内的数据库文件;
- locate: 依据/var/lib/mlocate/内的数据库记录, 找出用户所输入关键词的文件名

## 4. 磁盘与文件系统管理

### 4.1 Linux文件系统概要

#### 4.1.1 文件系统特性

Windows98以前主要使用的文件系统是FAT, Windows以后则主要使用NTFS. Linux则主要使用ext2、ext3、ext4.

ext2/3文件系统是索引式文件系统; FAT的文件系统则类似链表结构, 每个数据区块带有指针指向下一个数据区块.

- 传统文件系统: ext2、minix、FAT(用vfat模块)、iso9660(光盘等)
- 日志式文件系统: ext3、ext4、ReiserFS、Windows NTFS、IBM's JFS、ZFS
- 网络文件系统: NFS、SMBFS

#### 4.1.2 Linux的ext2文件系统

ext2文件系统格式化的时候基本是区分多个区块群组(block group), 每个区块群组有六个主要内容：

1. 数据区块(data block)
2. inode表(inode table)
3. 超级区块(superblock)
4. 文件系统描述说明(filesystem description)
5. 区块对照表(block bitmap)
6. inode对照表(inode bitmap)

##### 数据区块(data block)

在ext2文件系统中所支持的区块大小有1k、2k及4k三种, ext2文件系统的数据区块主要有以下限制

- 原则上, 区块的大小与数量在格式化完就不能够再修改(除非重新格式化)
- 在每个区块最多只能够放置一个文件的数据
- 如果文件大于区块大小, 则一个文件会占用多个区块的数量
- 若文件小于区块, 则该区块的剩余容量就不能够再被使用了(磁盘空间浪费)

##### inode表(inode table)

inode记录的数据至少有以下这些

- 该文件的读写属性(read、write、excute)
- 该文件的拥有者与用户组(owner、group)
- 该文件的大小
- 该文件建立或状态改变的时间(ctime)
- 最近一次的读取时间(atime)
- 最近修改的时间(mtime)
- 定义文件的标识(flag)、如SetUID
- 该文件真正的内容指向(pointer)

inode的数量与大小也是在格式化时就已经固定了, 除此之外inode还有以下特点:

- 每个iNode大小均为128B(新的ext4与xfs可设置为256B)
- 每个文件都仅会占用一个inode而已
- 因此文件系统能够建立的文件数量与inode的数量有关
- 系统读取文件时需要先找到inode, 并分析inode所记录的权限与用户是否符合, 若符合才能够读取区块的内容
- inode记录一个数据区块要使用4B, inode记录区块号码的区域定义为12个直接、1个间接、1个双间接、1个三间接记录区.

##### 超级区块(superblock)

超级区块是记录整个文件系统相关信息的地方, 没有超级区块, 就没有这个文件系统, 它记录的信息主要有:

- 数据区块与inode的总量
- 未使用与已使用的inode与数据区块数量
- 数据区块与inode的大小(block为1、2、4k, inode为128B或256B)
- 文件系统的挂载时间、最近一次写入数据的时间、最近一次检验磁盘(fsck)的时间等文件系统的相关信息
- 一个有效位数值, 若此文件系统已被挂载, 则有效位为0, 若未被挂载, 则有效位为1

##### 文件系统描述说明(filesystem description)

这个区段可以描述每个区块群组的开始与结束的区块, 以及说明每个区段(超级区块、对照表、inode对照表、数据区块)分别介于哪一个区块之间, 这部分也能够用dumpe2fs来观察

##### 区块对照表(block bitmap)

新增文件时总会用到区块, 那你要使用哪个区块来记录? 当然是选择空区块来记录新文件的数据. 那你怎么知道哪个区块是空的？这就要通过区块对照表的辅助, 从区块对照表当中可以知道哪些区块是空的， 系统能够快速的找到可使用的空区块来处理文件.

##### inode对照表(inode bitmap)

与区块对照表类似, inode对照表记录的使用与未使用的inode号码

##### dumpe2fs命令

dumpe2fs命令是一个查询ext系列超级区块信息的命令

#### 4.1.3 与目录树的关系

当我们在Linux下的文件系统建立一个目录时, 文件系统会分配一个inode与至少一块区块给该目录。其中, inode记录该目录的相关权限与属性, 并可记录分配到的那块区块号码. 而区块则是记录在这个目录下的文件名与该文件名占用的inode号码数据.

#### 4.1.4 ext2/ext3/ext4文件系统的文件存取

假设我们想要新增一个文件, 此时文件系统的操作是:

1. 先确定用户对于欲新增文件的目录文件的目录是否具有w与x的权限, 若有的话才能新增;
2. 根据inode对照表找到没有使用的inode号码, 并将新文件的权限、属性写入;
3. 根据区块对照表找到没有使用的区块号码, 并将实际的数据写入区块中, 且更新inode的区块指向数据;
4. 将刚刚写入的inode与区块数据同步更新inode对照表与区块对照表, 并更新超级区块的内容;

一般来说, 我们将inode表与数据区块称为数据存放区域, 其他例如超级区块、inode对照表、区块对照表等区段就被称为元数据(metadata).

##### 数据不一致与日志式文件系统

为了快速处理文件写入过程中出现的数据不一致的情况(例如写入过程中突然断电), 出现了日志式文件系统的解决方案:

1. 预备: 当系统要写入一个文件时, 会先在日志记录区块中记录某个文件准备写入的信息;
2. 实际写入: 开始写入文件的权限与数据, 开始更新metadata的数据;
3. 结束: 完后数据与meta的更新后, 在日志记录区块当中完成该文件的记录

ext3、4都是日志式文件系统

#### 4.1.5 Linux文件系统的运行

- 系统会将常用的文件数据放置到内存的缓冲区, 以加速文件系统的读写操作;
- 因此Linux的物理内存最后都会被用光, 这是正常的现象, 可加速系统性能;
- 若正常关机时, 关机命令都会主动调用sync来强制将内存中设置为Dirty的数据回写到磁盘中;
- 但若不正常关机(如断电、宕机等), 由于数据尚未回写到磁盘中, 因此重新启动后可能会花很多时间在进行磁盘校验, 甚至可能导致文件系统的损坏

#### 4.1.6 Linux VFS(virtual filesystem switch)

Linux支持多种文件系统, 都是通过一个名为VFS(virtual filesystem switch)的内核功能区读取文件系统. 也就是说, 整个Linux识别的文件系统其实都是VFS在进行管理, 我们用户并不需要知道每个硬盘分区上面的文件系统是什么, VFS会主动帮我们做好读取的操作, 抹平各个文件系统的差异.

#### 4.1.7 XFS文件系统简介

ext系列虽然支持度广, 但存在格式化超慢的问题. 因此从CentOS 7.x开始, 文件系统已经由默认的ext4变成了xfs这一个较适合高容量磁盘与巨型文件, 且性能佳的文件系统.

XFS文件系统中用xfs_info命令去观察超级区块内容, 类似于ext系列的dump2fs.

### 4.2 文件系统的简单操作

#### 4.2.1 磁盘与目录的容量

常用命令:

- df: 列出文件系统的整体磁盘使用量;
- du: 查看文件系统的磁盘使用量(常用在查看目录所占磁盘空间)

#### 4.2.2 硬链接和符号链接

##### 硬链接

- 硬链接的建立不消耗磁盘空间和inode, 硬链接只是在某个目录下新增一条文件名链接到mouinode号码的关联记录而已;
- 建立硬链接后, 如果你将任何一个文件名删除, 其实inode与区块都还是存在的, 此时你可以通过另一个文件名来读取到正确的文件数据;

硬链接的限制:

- 不能跨文件系统
- 不能链接目录

##### 符号链接

- 符号链接就是建立一个独立的文件, 而这个文件会让数据的读指向它链接的那个文件的文件名. 由于只是利用问价来做为指向的操作, 所以, 当源文件被删除后, 符号链接会报【无法打开某文件】(实际上就是找不到原始文件)
- 符号链接与Windows的快捷方式可以划上等号, 由符号链接所建立的文件为一个独立的新的文件, 所以会占用inode与区块

##### 相关命令

```bash
# 建立链接的命令
ln [-sf] 源文件 目标文件
# 选项与参数
#-s: 如果不加任何参数就进行链接, 那就是硬链接, 至于-s就是符号链接
#-f: 如果目标文件存在的话, 就主动的将目标文件直接删除后再建立

# 在/root目录下建立符号链接的例子
ln -s /etc/test test2
ll -i /etc/test /root/test2
# 打印结果
32424 -rw-r--r--. 2 root root 434 Jun 10 2011 /etc/test
23424 lrwxrwxrwx. 1 root root 12 Jun 23 22:23 /root/test2 -> /etc/test
```

### 4.3 磁盘的分区、格式化、检验与挂载

#### 4.3.1 相关常用命令

- lsblk: list block device的缩写, 作用是列出所有存储设备;
- blkid: 找出设备的UUID(universally unique identifier, 全局唯一标识符), 这个标识符可以拿来作为挂载或是使用这个设备或文件系统
- fdisk: MBR分区表分区
- gdisk: GPT分区表分区
- mkfs.xfs: 格式化为xfs文件系统
- mkfs.ext4: 格式化为ext4文件系统
- xfs_repair: XFS文件系统发生错乱时(如出现突然断电等), 进行文件系统校验(注意: 通常只有身为root且你的文件系统有问题的时候才使用这个命令, 否则在正常状况下使用此命令, 可能会造成对系统的危害, 通常使用这个命令的场合都是在系统出现极大的问题, 导致你在Linux启动的时候得进入单人单机模式下进行维护的操作时, 才必须使用此命令)
- fsck.ext4: ext4文件系统发生错乱时(如出现突然断电等), 进行文件系统校验(注意项同上)
- mount: 挂载磁盘分区(文件系统)
- 
- unmount: 卸载磁盘分区(文件系统)

#### 4.3.2 文件系统的挂载与卸载

文件系统的挂载点是目录, 而这个目录时进入磁盘分区(其实是文件系统)的入口, 在进行挂载前, 需要确定几件事:

- 单一文件系统不应该被重复挂载在不同的挂载点(目录)中;
- 单一的目录不应该重复挂载多个文件系统;
- 要作为挂载点的目录, 理论上应该都是空目录才行;
- 如果你要用来挂载的目录里面不是空, 那么挂载了新的文件系统之后, 原目录下的东西会暂时的隐藏, 等到这个新磁盘分区(文件系统)被卸载之后, 这个目录下原本的内容才会再次出现

#### 4.4 内存交换区

以前的年代内存不足, 因此那个可以将内存中的数据拿到硬盘中暂时存放的内存交换区(swap)就显得非常重要. 现在的主机内存虽然变大了不少, 但面对大型服务的时候, 预留内存交换分区来缓冲系统的内存使用量还是很重要的.

建立内存交换分区有以下方式:

- 设置一个内存交换分区
- 建立一个虚拟内存的文件

## 5. 文件与文件系统的压缩

### 5.1 Linux系统常见的压缩命令

#### 5.1.1 常见压缩文件

- *.Z: compress程序压缩的文件;
- *.zip: zip程序压缩的文件;
- *.gz: gzip程序压缩的文件;
- *.bz2: bzip2程序压缩的文件;
- *.tar: tar程序打包的文件, 并没有压缩过;
- *.tar.gz: tar程序打包的文件, 并且经过gzip的压缩;
- *.tar.bz2: tar程序打包的文件, 并且经过bzip2的压缩;
- *.tar.xz: tar程序打包的文件, 并且经过xz的压缩;

#### 5.1.2 gzip, zcat/zmore/zless/zgrep

gzip可以说是最应用最广的压缩命令了, 目前gzip可以解开compress、zip与gzip等软件所压缩的文件.当你使用gzip进行压缩时, 在默认的状态下原本的文件会被压缩成为.gz后缀的文件, 源文件就不再存在了, 这点与Windows的使用习惯有所不同.

cat/more/less 可以使用不同的方式来读取纯文本文件, 那zcat/zmore/zless则可以对应于cat/more/less的方式来读取纯文本文件被压缩后的压缩文件.另外, 如果你还想要从文字压缩文件当中找数据的话, 可以通过zgrep来查找关键词, 而不需要将压缩文件解开才以grep进行.

#### 5.1.3 bzip2, bzcat/bzmore/bzless/bzgrep

bzip2是压缩比比gzip还要好的压缩方式, 相关命令的用法也和gzip一样

#### 5.1.4 xz, xzcat/xzmore/xzless/xzgrep

xz这个压缩方式的压缩比比gzip和bzip2还要高, 相关命令的用法也和gzip一样

### 5.2 打包命令: tar

简单的使用例子

- 压缩: tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称;
- 查询: tar -jtv -f filename.tar.bz2;
- 解压缩: tar -jxv -f filename.tar.bz2 -C 的欲解压缩的目录;

### 5.3 XFS文件目录的备份与还原

#### 5.3.1 XFS文件系统备份xfsdump

xfsdump可以对xfs文件系统进行完整备份和增量备份, 在使用xfsdump的过程中主要有以下限制:

- xfsdump不支持没有挂载的文件系统备份, 所以只能备份已挂载的文件系统;
- xfsdump必须使用root的权限才能操作(涉及文件系统的关系);
- xfsdump只能备份xfs文件系统;
- xfsdump备份下来的数据(文件或存储媒介)只能让xfsrestore解析;
- xfsdump是通过文件系统的UUID来辨别各备份文件, 因此不能备份两个具有相同UUID的文件系统

#### 5.3.2 XFS文件系统还原xfsrestore

xfsdump的恢复使用的是xfsrestore这个命令.

## 6. vim程序编辑器

### 6.1 vi与vim

vi是UNIX-like系统中的老式编辑器(但功能很齐全), 很多软件的编辑接口都会主动调用vi.vim可以视作是vi的高级版本, vim可以用颜色或下划线的方式来显示一些特殊的信息.

### 6.2 vi的使用

vi共有3种模式：

- 一般命令模式
- 编辑模式
- 命令模式

一般命令模式可与编辑模式及命令行模式切换, 但编辑模式与命令行模式之间不可互相切换.

#### 6.2.1 一般命令模式

以vi打开一个文件就直接进入一般命令模式(这是默认的模式, 也简称为一般模式). 在这个模式中, 你可以使用【上下左右】按键来移动光标, 你可以使用【删除字符】或【删除整行】来处理文件内容, 也可以使用【复制、粘贴】来处理你的文件内容.

#### 6.2.2 编辑模式

在一般命令模式中可以进行删除、复制、粘贴等的操作, 但是却无法编辑文件的内容. 要等到你按下【i、I、o、O、a、A、r、R】等中任何一个字母之后才会进入编辑模式. 通常在Linux中, 按下这些按键时, 在界面的左下方会出现【INSERT】或【REPLACE】的字样, 此时才可以进行编辑, 如果要回到一般命令模式, 按下【Esc】这个按键即可退出编辑模式.

#### 6.2.3 命令行模式

在一般模式当中, 输入【:/?】三个中的任何一个按钮, 就可以将光标移动到最下面那一行. 在这个模式当中, 可以提供你【查找数据】的操作, 而读取、保存、批量替换字符、退出vi、显示行号等的操作也是在此模式中完成.