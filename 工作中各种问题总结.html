1.
mouseover - 鼠标指针经过任何子元素都会触发绑定在父元素上的mouseover事件,会事件冒泡
mouseout - 鼠标指针离开任何子元素时都会触发父元素上的out事件，会事件冒泡
mouseenter - 鼠标指针经过绑定的元素时触发事件，经过其子元素时，不会触发事件
mouseleave - 只有当鼠标离开绑定的元素时才会触发该事件
相关网址：
http://blog.csdn.net/lyc_2011_acm/article/details/8830720
http://blog.csdn.net/ocean1010/article/details/7394599

2.点击事件与鼠标拖动事件件的冲突(加个参数)

3.拖动事件取消全选（return false，取消默认动作）

4.z-index

5.position:relative & absolute

6.层叠样式权重

7.需求：iframe高度自适应（自动刷新获得当前高度）
http://www.zhangxinxu.com/wordpress/2010/12/%E5%B0%8Ftip%EF%BC%9Aiframe%E9%AB%98%E5%BA%A6%E5%8A%A8%E6%80%81%E8%87%AA%E9%80%82%E5%BA%94/

8.需求：iframe内部点击按钮弹出遮罩层覆盖父页面

9.jquery控制checkbox点击事件，第一次有效，后面就无效了
原代码：
var _check = $this.parents('li').find('.edit_check'); 
if(_check.attr('checked')){
	_check.attr('checked',false);
}else{
	_check.attr('checked',true);
}
改后的代码：
var _check = $this.parents('li').find('.edit_check'); 
if(_check.prop('checked')){
	_check.prop('checked',false);
}else{
	_check.prop('checked',true);
}
对表单元素进行操作最好用prop方法，而不用attr方法

10.input输入框在手机上阻止默认软键盘弹出事件，用readonly 属性，只读。
　　readonly="readonly"，该属性只适用于type=”text”或者”password”。

11.Jquery的validate插件input输入框校验失去焦点事件触发，显示错误信息弹窗得过程中，弹窗无法弹出的BUG，原因是input框不能在同一个节点，需要分别给各个弹窗套上DIV。

12.获取子iframe里面的内容：
　　window.frames['iframeId'];
　　getElemmentbyId('iframeId')只能获取该iframe的DOM对象，并不能访问iframe里面	的内容
　　获取父ifrmae里面的内容：
　　window.parent;

13.&#65279;导致页面顶部空白一行的问题，解决方法：
　　模板文件生成html文件之后会在body开头处加入一个可见的控制符&#65279，导致页面头部会出现一个空白行。原因是页面的编码是UTF-8 + BOM。
     这种编码方式一般会在windows操作系统中出现，比如WINDOWS自带的记事本等软件，在保存一个以UTF-8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。对于一般的文件，这样并不会产生什么麻烦。但对于 PHP来说，BOM是个大麻烦。因为PHP并不会忽略BOM，所以在读取、包含或者引用这些文件时，会把BOM作为该文件开头正文的一部分。根据嵌入式语言的特点，这串字符将被直接执行（显示）出来。由此造成即使页面的 top padding 设置为0，也无法让整个网页紧贴浏览器顶部，因为在html一开头有这3个隐藏字符&#65279！
　　遇到这种问题的解决方法就是用Editplus 2.12版本以上编辑器或者 EmEditor或者 UltraEdit（需要取消‘添加BOM’的相关选项）或者 Dreamweaver（需要取消‘添加BOM’的相关选项）重新保存一下utf-8格式的文档！

14.Object是没length属性的！！！！console.log(Object.length)  //undefined
　　 Object.prototype.length = function() {
　　     var count = 0;
　　     for(var i in this){
　　         count ++;
　　     }
　　     return count;
　　 };

15.option在除了火狐以外的浏览器是无法绑定事件的，如果要在option选择或点击的时候出发事件，只能通过select的change事件触发（和纯粹的点击事件的区别在于，change事件要选择值不同才会触发）,若是要获取选中option的相关属性，则可以：
$('select').change(function(){
  $(this).find('option:selected').attr(属性);
})

16.tr,td这种列表元素是设置min-height属性是无效的，可以设置height属性代替，因为里面的元素会自动把td、tr撑开。


17.我们平时写函数或者插件配置参数时用的||方法，是用弱类型转化，如果传进来的配置是0或false，就会默认为false。
function demo(name,data){
　　var name = name || "mayun";    //如果传进来的name是0或false,则name="mayun"
	var data = data || "mahuateng";//同理
}
18.enter键的提交事件是keydown的默认事件，在可预判之前执行。字符或者删除等操作事件都会在keyup之后才会生效
19.Jq在keypress事件中，按下是字符按键时，event.charcode会显示相应的代表字符ACSII编码值,event.keycode为0；按下是操作键时，event.charcode为0，会显示操作键相对应的event.keycode。在keydown事件中，无论按下字符按键还是操作键，都会返回相对应的event.keycode，event.charcode为0。原生环境测试结果一样，测试环境是火狐，ie没测。

20.跨域的各种知识点：jsonp、window.name、window.postMessage(data,url)(而接受方可以使用window.addEventListen(‘message’, receiveMessage, false)对数据进行接受)、websocket、CORS、document.domain等方法进行跨域。

21.关于setTimeout
在使用setTimeout(fun,time)方法时，应该只传入方法的function名，而不需要加小括号，否则将会视为立即调用。
例如：
function a(){
	//do something
}
setTimeout(a,500);
而不应该setTimeout(a(),500);
若是要传参数或者用call，apply方法时，则可用以下方法执行
1）匿名函数包裹法
setTimeout(function(){
	a(arg[0],arg[1]...)
},500);
setTimeout(function(){
	b.call(this)
},500);
2）用字符串拼接
var i = '111';
var k = '222';
setTimeout('a(' + i + ',' + k + ')',500)
3)用js原生bind方法,bind方法会返回一个指定作用域的函数，而不是立即执行
setTimeout(b.bind(this),500);
详见后面bind与call、apply的区别，不过原生bind方法只能兼容IE9及以上浏览器，MDN有相对应的Polyfill

22.setTimeout是异步方法，即使时间设为0，也会最后执行。
setTimeout(a,0);//会异步执行a方法，a方法会在程序的最后执行

23.移动端ios软键盘弹出，fixed失效问题。
http://www.cnblogs.com/yexiaochai/p/3561939.html

24.removeEventListener原则上是无法删除元素绑定的匿名函数的事件的，但可以通过以下方式删除：
document.getElementById('intro').addEventListener('click', function(){
	alert('WOW!');
    this.removeEventListener( 'click', arguments.calllee);
},false);
arguments对象包含了所有传递进来的参数以及该函数自身(callee)，所以可以通过callee的引用删除自身

25.分清encodeURIComponent、encode以及escape的区别

26.跨域技术优缺点比较：CORS(Cross-Origin Resource Sharing)可以使用post方法，且有onload、onerror这一系列的响应事件，兼容性是IE10及以上支持原生xhr的cors技术，而ie8,9则可以用XDR(XDomainRequest)替代方案实现。JSONP(JSON with padding)则兼容性好，几乎所有浏览器都支持，通过动态生成<script>标签，然后跨域调用达到跨域请求的目的，缺点就是安全性不高，而且不容易判断请求是否失败，只能通过判断规定时间内是否收到数据进行判断。
　　
27.疑问:获取元素#a的offset().top值(即$('#a').offset().top的值),把垂直滚动条拉到与#a元素平齐,获取$(document).scrollTop(),会发现两个值并不相同，而且差距还挺大

28.label标签里面包含img标签是，在IE8及以下会有个bug,for属性触发失败,如下所示
    <input id="fjl" name="source" value="fjl" type="radio">
    <label for="fjl"><img src="http://192.168.60.200/img_css/webdev/jjr.yl1001.com/2.0/images/fjl.jpg" alt="纷简历"></label>
    当在IE8及以下点击label标签时,radio并不会随之变化,解决方法,在img标签里面设置disabled属性，如下所示
    <label for="fjl"><img src="http://192.168.60.200/img_css/webdev/jjr.yl1001.com/2.0/images/fjl.jpg" alt="纷简历" disabled></label>
    或者用js解决

29.call与apply的区别主要在于参数的传入方式不一样，apply是传入数组，而call是像一般函数一样传入参数。bind与call、apply的主要区别则在于，bind返回的是函数，还需要用()执行，而call和apply则是立即执行，详见http://www.admin10000.com/document/6711.html，https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind

30.分清图片的预加载及懒加载，预加载是提前加载，主要是为了不影响加载速度的情况下提起加载图片，优化交互体验。懒加载则是延迟未在可视区域内的图片的加载时间，优化首屏加载速度，也是优化交互体验的一种手段。以下则是预加载的代码：
	$(function(){
	    var cache=[];

	    //编写一个预加载图片的jQuery函数
	    $.preLoadImages = function(){

	        //获取函数体的参数个数
	        var args_len = arguments.length;

	        // 循环参数个数，创建img元素
	        for(var i = 0; i < args_len; i++) {
	            var cacheImage = document.createElement('img');

	            //指定img元素的src属性为数组元素的值
	            cacheImge.src = arguments[i];

	            //将HTML元素加入到数组中，这样在网页上的任何位置引用图片时，将从缓存中获取所需的图片，从而提升用户的体验，使网站获得更好的流畅性
	            cache.push(cacheImage);
	        }    
	    }    
	});
	//预加载图片
	$.preLoadImages('images/sample1.jpg', 'images/sample2.jpg', 'images/sample3.jpg');
	//图片加载出错处理，用默认图片代替
	$(function(){
	    $("img").error(function(){
	        $(this).prop("src","images/planB.jpg");
	    });
	});

31.this的深入了解；https://gold.xitu.io/post/5857dad461ff4b00686cf97a
   其实我们平时调用的
   function a(){
   	console.log(this);
   };
   a();//打印出来是window
   其实等于a.call(undefined);
   之所以打印出来是window对象，是因为call方法传入context 是 null 或者 undefined 的话，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）
   因此上面的打印结果是 window。
   如果上面改成：
   function a(){
   	'use strict';
   	console.log(this);
   };
   a();//打印出来则是undefined

   b = '2222';
   function a(){
   	'use strict';
   	console.log(this.b);
   };
   a();//此时会报错，因为this是undefined而不是window

32.ES5的新特性汇总:https://gold.xitu.io/post/584f9ef7128fe100692e67e2
	Trailing commas are ok
	多余的逗号不报错，比如 {a:1,b:2,}

	No reserved words for property names
	属性名可以使用关键字和保留字了，比如 { if:1, else:2 }

	NaN, Infinity, undefined : are all constants
	NaN、Infinity、undefined 都是常量了，不可更改。

	parseInt() defaults to radix 10
	parseInt 第二个参数默认为 10（真好）

	/regexp/ produces new reg ex object every time
	正则字面量每次都会产生一个新的对象

	JSON.parse(), JSON.stringify()
	添加 JSON 序列化和反序列化

	Function.prototype.bind
	函数新增 bind 方法（贺老说 bind 写在后面有点不好用）

	String.prototype.trim
	字符串终于自带头尾去空格方法了，如 ' abc '.trim() === 'abc'

	Array.prototype.every, filter, forEach, indexOf, lastIndexOf, map, reduce, reduceRight, some
	数组添加了一系列方法，终于能脱离 Underscore.js 了

	Date.now()
	Date.now 现在才加进来的？可怕。

	Date.prototype.toISOString
	日期新增 toISOString 方法

	new Date(string) and Date.parse(string) will try ISO format 1st
	新增对 ISO 日期格式的支持

	Array.isArray()
	判断一个对象是不是数组……以前苦了大家了

	Object.keys(), Object.create(), Object.defineProperty, Object.defineProperties,
	Object.getOwnPropertyDescriptor(), Object.getOwnPropertyNames(obj), Object.getPrototypeOf(obj)

	Object.seal(), Object.freeze(), Object.preventExtensions(), Object.isSealed(), Object.isFrozen(),
	Object.isExtensible()
	对象新增一系列方法，使得在 JS 中模拟 Java 变得更丝滑。我最喜欢的还是 Object.create()

	Property attributes: writeable, value, enumerable, configurable, get, set
	对象的属性可以添加各种配置了

	Strict Mode:
	No more implied global variables within functions.
	this is not bound to the global object by function form.
	apply and call do not default to the global object.
	No with statement.
	Setting a writeable: false property will throw.
	Deleting a configurable: false property will throw.
	Restrictions on eval.
	eval and arguments are reserved.
	arguments not linked to parameters.
	No more arguments.caller or arguments.callee.
	No more octal literals.
	Duplicate names in an object literal or function parameters are a syntax error

	严格模式
	函数里没有隐式的全局变量了，你要创建全局变量必须是显式的。比如想用 a = 1 创建全局变量是不行的。
	this 不会默认指向全局对象（比如 window 或者 global）了。
	call 和 apply 也不会默认使用全局对象了。
	不准用 with
	如果一个属性的 writeable 是 false，那么你给这个属性赋值就会报错。
	如果一个属性的 configurable 是 false，那么你 delete 这个属性就会报错。
	对 eval 和 arguments 做出了限制。以下代码每行都会报错：

	eval = 17;
	arguments++;
	++eval;
	var obj = { set p(arguments) { } };
	var eval;
	try { } catch (arguments) { }
	function x(eval) { }
	function arguments() { }
	var y = function eval() { };
	var f = new Function("arguments", "'use strict'; return 17;");
	arguments 只保存原始参数。对形参的赋值不会对 arguments 有影响。
	不准用 arguments.caller 和 arguments.callee
	不支持八进制字面量，比如 var a = 015 会报错。
	对象字面量或者函数形参中，如果有重复的名字，就会报错。
	Strict Mode 更详细的参考，见 MDN。

33.编写可维护性的js代码：
	(1)遵循团队编码规范，常注释;
	(2)耦合要松散，做到松耦合(html与js松耦合,css与js松耦合等);
	(3)事件的处理程序应该与应用逻辑解耦;
	(4)不要随意改动不是自己定义的对象;
	(5)避免设置全局变量;
	(6)参数之间的比较要准确;
	(7)要设置常量;
	(8)要正确命名变量，从命名中看的出其意义;
	(9)命名多个变量只使用一个var，变量最好都有一个初始值，能证明其是什么类型的变量;

34.indexedDB的了解;

35.提高js的性能：
	(1)将在函数中会用到多次的全局对象储存为局部变量，减少遍历作用域链损耗的性能;
	(2)避免使用with语句，同理是为了减少执行代码的作用域链长度;
	(3)访问数组的效率是明显比访问对象要高的，因为访问数组的属性等于在其原型链上对拥有该名称的属性进行一次搜索，所以，如果需要多次对对象的属性进行查找时，最好先用变量保存其属性值，提高性能;
	(4)使用文档碎片ducument.createDocumentFragment()或者通过字符串在innerHTML的方法创建html节点。

36.switch(){
		case 1 :
		break;

		case '2' :
		break;

		case '3' :
		break;
	}
	并不支持 case 1 || '2' : 这种写法(已亲自写测试代码验证过)

37.离线储存：以每个来源为单位(协议，域，端口)，cookies支持的最大存储空间是4KB，sessionStorage、localStorage支持的是5MB，indexedDB是50MB。以上都遵循同源策略。
38.toString()方法和String()方法的区别在于，null和undefined没有toString()方法，而String()方法则可以将null和undefined强制转化成相对应的字符串;
	undefined.toString() //报错
	null.toString() //报错
	String(null)//'null'
	String(undefined)//'undefined'

39.在我们使用三列布局的时候，一般我们会先使用左右固定端使用float属性，中间自适应端用padding或者margin隔开固定端的距离，但在IE7及以下使用这个布局，并使用padding属性隔开间隔，并且中间的自适应快用到去浮动相关属性的时候，包括overflow:hidden;或者clearfix类去浮动等，自适应块的盒子模型会转化成borderbox，所以会引发bug，解决方法是使用margin属性隔开。

40.在微信自带浏览器中，但网站页面滑到最顶部，继续手势向下滑动拉动页面向上滑动时，并不会触发touchend事件(?先保留疑问)，但还是会触发touchstart和touchmove事件。

41.构建一个属于自己的手势库，http://qianduan.guru/2016/08/13/gesture_detection_in_html5/

42.touch事件中，touches、targetTouches、及changedTouches数组的区别：
	stackoverflow原文地址http://stackoverflow.com/questions/7056026/variation-of-e-touches-e-targettouches-and-e-changedtouches,原文回答如下
	We have the following lists:
	(1)touches: A list of information for every finger currently touching the screen
	(2)targetTouches: Like touches, but is filtered to only the information for finger touches that started out within the same node
	(3)changedTouches: A list of information for every finger involved in the event (see below) To better understand what might be in these lists, let’s go over some examples quickly

	They vary in the following pattern:
	(1)When I put a finger down, all three lists will have the same information. It will be in changedTouches because putting the finger down is what caused the event
	(2)When I put a second finger down, touches will have two items, one for each finger. targetTouches will have two items only if the finger was placed in the same node as the first finger. changedTouches will have the information related to the second finger, because it’s what caused the event
	(3)If I put two fingers down at exactly the same time, it’s possible to have two items in changedTouches, one for each finger
	(4.)If I move my fingers, the only list that will change is changedTouches and will contain information related to as many fingers as have moved (at least one).
	(5)When I lift a finger, it will be removed from touches, targetTouches and will appear in changedTouches since it’s what caused the event
	(6)Removing my last finger will leave touches and targetTouches empty, and changedTouches will contain information for the last finger

	翻译如下：
	关于这几个列表信息的解释如下：
	(1)touches:当前触摸着屏幕的每个手指操作信息的Touch对象的数组;
	(2)targetTouches:和touches类似，但会经过过滤，仅保存手指（一个或多个）于同一个节点下开始触摸事件的操作信息的Touch对象的数组;
	(3)changedTouches:当前参与到触摸事件中的每个手指的操作信息的Touch对象的数组;

	为了更好的理解以上三个数组的区别，我们将通过以下例子进行解释：
	(1)当我放下一个手指接触屏幕时，所有的这三个数组会存放着相同的对象及相关信息。Touch对象会出现在changedTouches数组是因为手指接触屏幕的时候会触发事件;
	(2)当我放下第二个根手指的手，touches数组将会有两个Touch对象，每个都存放着相对应的手指相对应的操作信息;当且仅当刚放下的第二根手指触摸区域所在的节点和第一根手指相同的时候，targetTouches才会有两个Touch对象;changedTouches数组将只有第二个根手指操作信息的Touch对象，因为是它触发了事件;
	(3)如果我在同一时间内放下两个手指接触屏幕，changedTouches数组将会有两个Touch对象，每个都存放着相对应的手指相对应的操作信息;
	(4)当我在屏幕上移动我的手指时，唯一会改变的数组是changedTouches，它存放的Touch对象数量会随着移动的手指数的改变而改变(最少会有一个Touch对象);
	(5)当我收起我的一根手指(离开屏幕)的时候,该手指对应的Touch对象将会从touches、targetTouches数组中消失，同时会在changedTouches数组中出现，因为是它触发了事件;
	(6)当我收起我最后一根手指(离开屏幕)的时候，touches、targetTouches数组将会被清空，而此时，changedTouches数组将会存放最后一根手指对应的Touch对象;

	以下是高程的解释：
	(1)touches:表示当前跟踪的触摸操作的Touch对象的数组;
	(2)targetTouches:特定于事件目标的Touch对象的数组;
	(3)changedTouches:表示自上次触摸以来发生了什么改变的Touch对象的数组

43.background-size中cover与contain的区别：
   cover代表背景铺满整个元素，以背景图的最小边为基准，超出元素的背景图会被截掉;
   contain代表元素包含整个背景，以背景图的最大边为基准，在以元素能包含整个背景图的前提下，使背景图扩到最大，有可能会留白边;

44.不能在css样式声明块内添加注释，否则ie6,7下回解析异常，造成样式错误，如下为错误示范：
	.demo{
		width:100px;
		height:100px;
		// 此处是注释
		border:solid 1px #e5e5e5;
	}

45.深入了解组件开发：http://www.html-js.com/article/JS-from-zero-single-row-JavaScript-component-development-method

46.对象继承的若干种方法：http://purplebamboo.github.io/2014/07/13/javascript-oo-class/

47.//已证实为错题，忽略之
	疑问：一道js题目：
	实现以下代码
	var  a = "  abcd  ";
	a.st();
	console.log(a); //"absd",去掉前后空格

48.事件绑定如下所示
	<!DOCTYPE html>
	<html>
		<head>
			<meta charset="UTF-8">
		</head>
		<body>
		  	<a id="btn1" onclick="fun1();" href="javascript:fun2();">btn</a>
		  	<script type="text/javascript">
				function fun1(){
					console.log("111");
				}
				function fun2(){
					console.log("222");
				}
				
				var btn = document.getElementById("btn1");
				
				btn.addEventListener("click",function(){
					console.log("333");
				});
			</script>
		</body>
	</html>

	在以上代码中
	1.a标签的href中的代码总是最后执行，最低的优先级。
	2.无论是 onclick 还是 addEventListener 的执行顺序是按照 绑定的顺序在执行，就是先绑定的就先执行。
	3.如果 onclick 事件被重复绑定，则以最后一次的绑定所在的顺序为准。
	4.如果在DOM中直接使用onclick ，并且没有覆盖，则onclick的绑定是早于 addEventListener 的。
	5.如果绑定多个 addEventListener 事件，在任意一个事件中 stopPropagation(); 都会阻止事件的冒泡，但不会阻止后续事件的执行。

	详见https://zhuanlan.zhihu.com/p/24620643?refer=dreawer

49.:nth-child可以选择父元素下的字元素，:nth-of-type也可以。但是它们到底有什么区别呢？ 
	其实区别很简单：:nth-of-type为什么要叫:nth-of-type？因为它是以"type"来区分的。也就是说：ele:nth-of-type(n)是指父元素下第n个ele元素， 
	而ele:nth-child(n)是指父元素下第n个元素且这个元素为ele，若不是，则选择失败。 
	详见我学习代码文件夹的测试程序及以下网址：
	http://www.jb51.net/css/142398.html
	https://segmentfault.com/q/1010000004100714

50.深入理解instanceof：http://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/
   var a = 'abc';
   a instanceof String; //false
   var b = new String('abc');
   b instanceof String; //true

   JavaScript instanceof 运算符代码
	 function instance_of(L, R) {//L 表示左表达式，R 表示右表达式
	  var O = R.prototype;// 取 R 的显示原型
	  L = L.__proto__;// 取 L 的隐式原型
	  while (true) { 
	    if (L === null) 
	      return false; 
	    if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true 
	      return true; 
	    L = L.__proto__; 
	  } 
	 }

51.css样式加载不出来可能的原因：
   http://www.cnblogs.com/crizygo/p/5466444.html
   http://blog.csdn.net/a8761087/article/details/49910435/

	如果你的浏览器加载不上外联css（注意是全部加载不上，这里排除部分样式不兼容问题）：
	1.首先考虑是否css路径错误。
	2.在样式最开始有写注释，而当中文注释中的汉字为奇数个数时，会与结尾的“*/”组合成合法字符，以至于注释不能及时关闭，这样后续样式全部被自动注释。
	3.css文件中指定的编码与页面不统一，浏览器用页面编码解析css，自然会出错。我的IE更新到IE11时遇到了这个问题，html给的gb2312，css文件头给了的@charset"utf-8",css完全加不上。
	  例：<meta http-equiv="Content-Type" content="text/html; charset=gbk" />
	        <link href="join_us.css" type="text/css" rel="stylesheet" charset=“utf-8”>
	        （1） 外联css文件开头给了@charset "utf-8"
	        （2）CSS文件中未指定@charset头声明，导致IE默认使用页面编码来解码CSS文件。
	在这里解释一下，gb2312和gbk都是较早的国标码，主要用于编解码常用汉字。而utf-8更国际化一些，同时适用中文，基于英文的平台使用utf-8。GBK、GB2312等与UTF8之间都必须通过Unicode编码才能相互转换。

	4.IE不支持引入外部的Css文件,并且提示MINE Type类型不匹配。.css文件不是minetype 类型，原因可能是这个.css文件是你创建的其他类型（比如txt）文件然后改的后缀。
	   （1）那就重建一个css文件，把代码copy过去。
	   （2）或者下载FilesTypeMan 软件，直接修改文件后缀的minetype类型。

	5.看一下你的HTML头部的DOCTYPE 声明
	<!DOCTYPE>声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。在 HTML 4.01 中，<!DOCTYPE> 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。
	HTML5 不基于 SGML，所以不需要引用 DTD。
	<!DOCTYPE html> HTML5声明。
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">这个是dw自动在网页文件页增加了dtd信息(可以删. 删除后，浏览器会使用的默认dtd.)
	该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。还有很多。。。
	本地的外联css加不上，把页面头部的 <!DOCTYPE html>  把html去掉 就ok了。

	6.如果使用@import，当css文件发生改动时，客户端IE6将不会刷新该css。

	=================================================================分割线====================================================================
	微软的官方文档，给出的解释是微软对浏览器的安全机制作了一些修改，会拒绝加载MIME type不匹配的CSS文件。 
	以此，可分析出原因。你的.css文件并不是minetype 类型的css文件，为什么呢？仔细想想,你的这个.css文件是不是你创建的txt文件然后改的后缀?如果是，那么它虽然后缀是css,但其实不是css文件。解决方式2种。

	## 方法1 ## 
	把css文件中代码复制出来,重新建个文件,(记住,要用能创建css文件的工具创建,不要创建记事本再改后缀) 然后把复制的代码粘贴进去即可

	## 方法2 ##
	下载FilesTypeMan 软件。 用于修改文件后缀的minetype类型。
	下载后打开，会卡顿一会儿,这是软件在获取电脑所有后缀文件信息,等待出现所有后缀文件列表。
	你找到.css后缀的文件,右键 Properties 选项会出现该后缀的配置信息,找到MIME TYPE 项 ,值改成 text/css 即可

52.String.prototype.indexOf()和String.prototype.lastIndexOf(searchValue,fromIndex)的区别：
	indexOf是从fromIndex向后搜索，lastIndexOf是从fromIndex向前搜索，但是两者返回的都是searchValue位于string中的位置值，如果搜索不到则返回-1。

53.String.prototype.replace(regexp|substring,newsubString|function)方 法中，如果 第一个参数传的事字符串，那么，它只会替换第一个匹配的子字符串，要想全 部替换，必须使用正则：
	var text = "cat,bat,sat,fat";
	var res = text.replace('at','ond');
	console.log(res); //"cond,bat,sat,fat"

	res = text.replace(/at/g,'ond');
	console.log(res); //"cond,bond,sond,fond"

54.了解js 中new的运行机制：
	function Animal(name){
        this.name = name;
    }
    Animal.color = "black";
    Animal.prototype.say = function(){
        console.log("I'm " + this.name);
    };
    var cat = new Animal("cat");

    console.log(
       cat.name,  //cat
       cat.height //undefined
    );
    cat.say(); //I'm cat

    console.log(
       Animal.name, //Animal
       Animal.color //black
    );
    Animal.say(); //Animal.say is not a function
	
	JS引擎执行这句代码时，在内部做了很多工作，用伪代码模拟其工作流程如下：
	new Animal("cat") = {
	    var obj = {};
	    obj.__proto__ = Animal.prototype;
	    var result = Animal.call(obj,"cat");
	    return typeof result === 'object'? result : obj;
	}

	（1）创建一个空对象obj;
	（2）把obj的__proto__ 指向Animal的原型对象prototype，此时便建立了obj对象的原型链：obj->Animal.prototype->Object.prototype->null
	    【如果你不了解JS原型链，请先阅读：JS原型和原型链】
	（3）在obj对象的执行环境调用Animal函数并传递参数“cat”。 相当于var result = obj.Animal("cat")。
	     当这句执行完之后，obj便产生了属性name并赋值为"cat"。【关于JS中call的用法请阅读：JS的call和apply】
	（4）考察第3步返回的返回值，如果无返回值或者返回一个非对象值，则将obj返回作为新对象；否则会将返回值作为新对象返回。

55.柯里化和反柯里化

56.在函数中return a() 和 a()的区别		
		
