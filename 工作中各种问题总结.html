1.
mouseover - 鼠标指针经过任何子元素都会触发绑定在父元素上的mouseover事件,会事件冒泡
mouseout - 鼠标指针离开任何子元素时都会触发父元素上的out事件，会事件冒泡
mouseenter - 鼠标指针经过绑定的元素时触发事件，经过其子元素时，不会触发事件
mouseleave - 只有当鼠标离开绑定的元素时才会触发该事件
相关网址：
http://blog.csdn.net/lyc_2011_acm/article/details/8830720
http://blog.csdn.net/ocean1010/article/details/7394599

2.点击事件与鼠标拖动事件件的冲突(加个参数)

3.拖动事件取消全选（return false，取消默认动作）

4.z-index

5.position:relative & absolute

6.层叠样式权重

7.需求：iframe高度自适应（自动刷新获得当前高度）
http://www.zhangxinxu.com/wordpress/2010/12/%E5%B0%8Ftip%EF%BC%9Aiframe%E9%AB%98%E5%BA%A6%E5%8A%A8%E6%80%81%E8%87%AA%E9%80%82%E5%BA%94/

8.需求：iframe内部点击按钮弹出遮罩层覆盖父页面

9.jquery控制checkbox点击事件，第一次有效，后面就无效了
原代码：
var _check = $this.parents('li').find('.edit_check'); 
if(_check.attr('checked')){
	_check.attr('checked',false);
}else{
	_check.attr('checked',true);
}
改后的代码：
var _check = $this.parents('li').find('.edit_check'); 
if(_check.prop('checked')){
	_check.prop('checked',false);
}else{
	_check.prop('checked',true);
}
对表单元素进行操作最好用prop方法，而不用attr方法

10.input输入框在手机上阻止默认软键盘弹出事件，用readonly 属性，只读。
　　readonly="readonly"，该属性只适用于type=”text”或者”password”。

11.Jquery的validate插件input输入框校验失去焦点事件触发，显示错误信息弹窗得过程中，弹窗无法弹出的BUG，原因是input框不能在同一个节点，需要分别给各个弹窗套上DIV。

12.获取子iframe里面的内容：
　　window.frames['iframeId'];
　　getElemmentbyId('iframeId')只能获取该iframe的DOM对象，并不能访问iframe里面	的内容
　　获取父ifrmae里面的内容：
　　window.parnet;

13.&#65279;导致页面顶部空白一行的问题，解决方法：
　　模板文件生成html文件之后会在body开头处加入一个可见的控制符&#65279，导致页面头部会出现一个空白行。原因是页面的编码是UTF-8 + BOM。
     这种编码方式一般会在windows操作系统中出现，比如WINDOWS自带的记事本等软件，在保存一个以UTF-8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。对于一般的文件，这样并不会产生什么麻烦。但对于 PHP来说，BOM是个大麻烦。因为PHP并不会忽略BOM，所以在读取、包含或者引用这些文件时，会把BOM作为该文件开头正文的一部分。根据嵌入式语言的特点，这串字符将被直接执行（显示）出来。由此造成即使页面的 top padding 设置为0，也无法让整个网页紧贴浏览器顶部，因为在html一开头有这3个隐藏字符&#65279！
　　遇到这种问题的解决方法就是用Editplus 2.12版本以上编辑器或者 EmEditor或者 UltraEdit（需要取消‘添加BOM’的相关选项）或者 Dreamweaver（需要取消‘添加BOM’的相关选项）重新保存一下utf-8格式的文档！

14.Object是没length属性的！！！！console.log(Object.length)  //undefined
　　 Object.prototype.length = function() {
　　     var count = 0;
　　     for(var i in this){
　　         count ++;
　　     }
　　     return count;
　　 };

15.option在除了火狐以外的浏览器是无法绑定事件的，如果要在option选择或点击的时候出发事件，只能通过select的change事件触发（和纯粹的点击事件的区别在于，change事件要选择值不同才会触发）,若是要获取选中option的相关属性，则可以：
$('select').change(function(){
  $(this).find('option:selected').attr(属性);
})

16.tr,td这种列表元素是设置min-height属性是无效的，可以设置height属性代替，因为里面的元素会自动把td、tr撑开。


17.我们平时写函数或者插件配置参数时用的||方法，是用弱类型转化，如果传进来的配置是0或false，就会默认为false。
function demo(name,data){
　　var name = name || "mayun";    //如果传进来的name是0或false,则name="mayun"
	var data = data || "mahuateng";//同理
}
18.enter键的提交事件是keydown的默认事件，在可预判之前执行。字符或者删除等操作事件都会在keyup之后才会生效
19.Jq在keypress事件中，按下是字符按键时，event.charcode会显示相应的代表字符ACSII编码值,event.keycode为0；按下是操作键时，event.charcode为0，会显示操作键相对应的event.keycode。在keydown事件中，无论按下字符按键还是操作键，都会返回相对应的event.keycode，event.charcode为0。原生环境测试结果一样，测试环境是火狐，ie没测。

20.跨域的各种知识点：jsonp、window.name、window.postMessage(data,url)(而接受方可以使用window.addEventListen(‘message’, receiveMessage, false)对数据进行接受)、websocket、CORS、document.domain等方法进行跨域。

21.关于setTimeout
在使用setTimeout(fun,time)方法时，应该只传入方法的function名，而不需要加小括号，否则将会视为立即调用。
例如：
function a(){
	//do something
}
setTimeout(a,500);
而不应该setTimeout(a(),500);
若是要传参数或者用call，apply方法时，则可用以下方法执行
1）匿名函数包裹法
setTimeout(function(){
	a(arg[0],arg[1]...)
},500);
setTimeout(function(){
	b.call(this)
},500);
2）用字符串拼接
var i = '111';
var k = '222';
setTimeout('a(' + i + ',' + k + ')',500)
3)用js原生bind方法,bind方法会返回一个指定作用域的函数，而不是立即执行
setTimeout(b.bind(this),500);
详见后面bind与call、apply的区别，不过原生bind方法只能兼容IE9及以上浏览器，MDN有相对应的Polyfill

22.setTimeout是异步方法，即使时间设为0，也会最后执行。
setTimeout(a,0);//会异步执行a方法，a方法会在程序的最后执行

23.移动端ios软键盘弹出，fixed失效问题。
http://www.cnblogs.com/yexiaochai/p/3561939.html

24.removeEventListener原则上是无法删除元素绑定的匿名函数的事件的，但可以通过以下方式删除：
document.getElementById('intro').addEventListener('click', function(){
	alert('WOW!');
    this.removeEventListener( 'click', arguments.calllee);
},false);
arguments对象包含了所有传递进来的参数以及该函数自身(callee)，所以可以通过callee的引用删除自身

25.分清encodeURIComponent、encode以及escape的区别

26.跨域技术优缺点比较：CORS(Cross-Origin Resource Sharing)可以使用post方法，且有onload、onerror这一系列的响应事件，兼容性是IE10及以上支持原生xhr的cors技术，而ie8,9则可以用XDR(XDomainRequest)替代方案实现。JSONP(JSON with padding)则兼容性好，几乎所有浏览器都支持，通过动态生成<script>标签，然后跨域调用达到跨域请求的目的，缺点就是安全性不高，而且不容易判断请求是否失败，只能通过判断规定时间内是否收到数据进行判断。
　　
27.疑问:获取元素#a的offset().top值(即$('#a').offset().top的值),把垂直滚动条拉到与#a元素平齐,获取$(document).scrollTop(),会发现两个值并不相同，而且差距还挺大

28.label标签里面包含img标签是，在IE8及以下会有个bug,for属性触发失败,如下所示
    <input id="fjl" name="source" value="fjl" type="radio">
    <label for="fjl"><img src="http://192.168.60.200/img_css/webdev/jjr.yl1001.com/2.0/images/fjl.jpg" alt="纷简历"></label>
    当在IE8及以下点击label标签时,radio并不会随之变化,解决方法,在img标签里面设置disabled属性，如下所示
    <label for="fjl"><img src="http://192.168.60.200/img_css/webdev/jjr.yl1001.com/2.0/images/fjl.jpg" alt="纷简历" disabled></label>
    或者用js解决

29.call与apply的区别主要在于参数的传入方式不一样，apply是传入数组，而call是像一般函数一样传入参数。bind与call、apply的主要区别则在于，bind返回的是函数，还需要用()执行，而call和apply则是立即执行，详见http://www.admin10000.com/document/6711.html，https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind

30.分清图片的预加载及懒加载，预加载是提前加载，主要是为了不影响加载速度的情况下提起加载图片，优化交互体验。懒加载则是延迟未在可视区域内的图片的加载时间，优化首屏加载速度，也是优化交互体验的一种手段。以下则是预加载的代码：
	$(function(){
	    var cache=[];

	    //编写一个预加载图片的jQuery函数
	    $.preLoadImages = function(){

	        //获取函数体的参数个数
	        var args_len = arguments.length;

	        // 循环参数个数，创建img元素
	        for(var i = 0; i < args_len; i++) {
	            var cacheImage = document.createElement('img');

	            //指定img元素的src属性为数组元素的值
	            cacheImge.src = arguments[i];

	            //将HTML元素加入到数组中，这样在网页上的任何位置引用图片时，将从缓存中获取所需的图片，从而提升用户的体验，使网站获得更好的流畅性
	            cache.push(cacheImage);
	        }    
	    }    
	});
	//预加载图片
	$.preLoadImages('images/sample1.jpg', 'images/sample2.jpg', 'images/sample3.jpg');
	//图片加载出错处理，用默认图片代替
	$(function(){
	    $("img").error(function(){
	        $(this).prop("src","images/planB.jpg");
	    });
	});

31.this的深入了解；https://gold.xitu.io/post/5857dad461ff4b00686cf97a
   其实我们平时调用的
   function a(){
   	console.log(this);
   };
   a();//打印出来是window
   其实等于a.call(undefined);
   之所以打印出来是window对象，是因为call方法传入context 是 null 或者 undefined 的话，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）
   因此上面的打印结果是 window。
   如果上面改成：
   function a(){
   	'use strict';
   	console.log(this);
   };
   a();//打印出来则是undefined

32.ES5的新特性汇总:https://gold.xitu.io/post/584f9ef7128fe100692e67e2
	Trailing commas are ok
	多余的逗号不报错，比如 {a:1,b:2,}

	No reserved words for property names
	属性名可以使用关键字和保留字了，比如 { if:1, else:2 }

	NaN, Infinity, undefined : are all constants
	NaN、Infinity、undefined 都是常量了，不可更改。

	parseInt() defaults to radix 10
	parseInt 第二个参数默认为 10（真好）

	/regexp/ produces new reg ex object every time
	正则字面量每次都会产生一个新的对象

	JSON.parse(), JSON.stringify()
	添加 JSON 序列化和反序列化

	Function.prototype.bind
	函数新增 bind 方法（贺老说 bind 写在后面有点不好用）

	String.prototype.trim
	字符串终于自带头尾去空格方法了，如 ' abc '.trim() === 'abc'

	Array.prototype.every, filter, forEach, indexOf, lastIndexOf, map, reduce, reduceRight, some
	数组添加了一系列方法，终于能脱离 Underscore.js 了

	Date.now()
	Date.now 现在才加进来的？可怕。

	Date.prototype.toISOString
	日期新增 toISOString 方法

	new Date(string) and Date.parse(string) will try ISO format 1st
	新增对 ISO 日期格式的支持

	Array.isArray()
	判断一个对象是不是数组……以前苦了大家了

	Object.keys(), Object.create(), Object.defineProperty, Object.defineProperties,
	Object.getOwnPropertyDescriptor(), Object.getOwnPropertyNames(obj), Object.getPrototypeOf(obj)

	Object.seal(), Object.freeze(), Object.preventExtensions(), Object.isSealed(), Object.isFrozen(),
	Object.isExtensible()
	对象新增一系列方法，使得在 JS 中模拟 Java 变得更丝滑。我最喜欢的还是 Object.create()

	Property attributes: writeable, value, enumerable, configurable, get, set
	对象的属性可以添加各种配置了

	Strict Mode:
	No more implied global variables within functions.
	this is not bound to the global object by function form.
	apply and call do not default to the global object.
	No with statement.
	Setting a writeable: false property will throw.
	Deleting a configurable: false property will throw.
	Restrictions on eval.
	eval and arguments are reserved.
	arguments not linked to parameters.
	No more arguments.caller or arguments.callee.
	No more octal literals.
	Duplicate names in an object literal or function parameters are a syntax error

	严格模式
	函数里没有隐式的全局变量了，你要创建全局变量必须是显式的。比如想用 a = 1 创建全局变量是不行的。
	this 不会默认指向全局对象（比如 window 或者 global）了。
	call 和 apply 也不会默认使用全局对象了。
	不准用 with
	如果一个属性的 writeable 是 false，那么你给这个属性赋值就会报错。
	如果一个属性的 configurable 是 false，那么你 delete 这个属性就会报错。
	对 eval 和 arguments 做出了限制。以下代码每行都会报错：

	eval = 17;
	arguments++;
	++eval;
	var obj = { set p(arguments) { } };
	var eval;
	try { } catch (arguments) { }
	function x(eval) { }
	function arguments() { }
	var y = function eval() { };
	var f = new Function("arguments", "'use strict'; return 17;");
	arguments 只保存原始参数。对形参的赋值不会对 arguments 有影响。
	不准用 arguments.caller 和 arguments.callee
	不支持八进制字面量，比如 var a = 015 会报错。
	对象字面量或者函数形参中，如果有重复的名字，就会报错。
	Strict Mode 更详细的参考，见 MDN。

33.编写可维护性的js代码：
	(1)遵循团队编码规范，常注释;
	(2)耦合要松散，做到松耦合(html与js松耦合,css与js松耦合等);
	(3)事件的处理程序应该与应用逻辑解耦;
	(4)不要随意改动不是自己定义的对象;
	(5)避免设置全局变量;
	(6)参数之间的比较要准确;
	(7)要设置常量;
	(8)要正确命名变量，从命名中看的出其意义;
	(9)命名多个变量只使用一个var，变量最好都有一个初始值，能证明其是什么类型的变量;

34.indexedDB的了解;

35.提高js的性能：
	(1)将在函数中会用到多次的全局对象储存为局部变量，减少遍历作用域链损耗的性能;
	(2)避免使用with语句，同理是为了减少执行代码的作用域链长度;
	(3)访问数组的效率是明显比访问对象要高的，因为访问数组的属性等于在其原型链上对拥有该名称的属性进行一次搜索，所以，如果需要多次对对象的属性进行查找时，最好先用变量保存其属性值，提高性能;
	(4)使用文档碎片ducument.createDocumentFragment()或者通过字符串在innerHTML的方法创建html节点。

36.switch(){
		case 1 :
		break;

		case '2' :
		break;

		case '3' :
		break;
	}
	并不支持 case 1 || '2' : 这种写法(已亲自写测试代码验证过)

37.离线储存：以每个来源为单位(协议，域，端口)，cookies支持的最大存储空间是4KB，sessionStorage、localStorage支持的是5MB，indexedDB是50MB。以上都遵循同源策略。
38.toString()方法和String()方法的区别在于，null和undefined没有toString()方法，而String()方法则可以将null和undefined强制转化成相对应的字符串;
	undefined.toString() //报错
	null.toString() //报错
	String(null)//'null'
	String(undefined)//'undefined'

39.在我们使用三列布局的时候，一般我们会先使用左右固定端使用float属性，中间自适应端用padding或者margin隔开固定端的距离，但在IE7及以下使用这个布局，病使用padding属性隔开间隔，并且中间的自适应快用到去浮动相关属性的时候，包括overflow:hidden;或者clearfix类去浮动等，自适应块的盒子模型会转化成borderbox，所以会引发bug，解决方法是使用margin属性隔开。
		

		

补充：
54.柯里化和反柯里化
55.在函数中return a() 和 a()的区别		
		
